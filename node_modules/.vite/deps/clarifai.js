import {
  __commonJS
} from "./chunk-LQ2VYIYD.js";

// node_modules/axios/dist/browser/axios.cjs
var require_axios = __commonJS({
  "node_modules/axios/dist/browser/axios.cjs"(exports, module) {
    "use strict";
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString = typeOfTest("string");
    var isFunction = typeOfTest("function");
    var isNumber = typeOfTest("number");
    var isObject = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject(val) && isFunction(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing)
        return null;
      if (isArray(thing))
        return thing;
      let i = thing.length;
      if (!isNumber(i))
        return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      value = +value;
      return Number.isFinite(value) ? value : defaultValue;
    };
    var ALPHA = "abcdefghijklmnopqrstuvwxyz";
    var DIGIT = "0123456789";
    var ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      while (size--) {
        str += alphabet[Math.random() * length | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
    var utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable
    };
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype$1 = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    var httpAdapter = null;
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value))
          return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    var FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    var Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    var platform$1 = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var hasStandardBrowserEnv = ((product) => {
      return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
    })(typeof navigator !== "undefined" && navigator.product);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var utils = Object.freeze({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      hasStandardBrowserEnv
    });
    var platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === "__proto__")
          return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var defaults$1 = defaults;
    var ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value))
        return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$1;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    var cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure) {
          const cookie = [name + "=" + encodeURIComponent(value)];
          utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils$1.isString(path) && cookie.push("path=" + path);
          utils$1.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var isURLSameOrigin = platform.hasStandardBrowserEnv ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test(navigator.userAgent);
        const urlParsingNode = document.createElement("a");
        let originURL;
        function resolveURL(url) {
          let href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return (e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
      };
    }
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        let requestData = config.data;
        const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
        let { responseType, withXSRFToken } = config;
        let onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        let contentType;
        if (utils$1.isFormData(requestData)) {
          if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
            requestHeaders.setContentType(false);
          } else if ((contentType = requestHeaders.getContentType()) !== false) {
            const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
            requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
          }
        }
        let request = new XMLHttpRequest();
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (platform.hasStandardBrowserEnv) {
          withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
          if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
            const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
            if (xsrfValue) {
              requestHeaders.set(config.xsrfHeaderName, xsrfValue);
            }
          }
        }
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        }
        if (config.cancelToken || config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(fullPath);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    var adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i = 0; i < length; i++) {
          nameOrAdapter = adapters2[i];
          let id;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError(`Unknown adapter '${id}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id || "#" + i] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError(
            `There is no suitable adapter to dispatch the request ` + s,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b, caseless) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(a, b, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
      };
      utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    var VERSION = "1.6.7";
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy;
            Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack;
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners)
            return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message, config, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module.exports = axios;
  }
});

// node_modules/clarifai/dist/helpers.js
var require_helpers = __commonJS({
  "node_modules/clarifai/dist/helpers.js"(exports, module) {
    "use strict";
    var SUCCESS_CODES = [200, 201];
    module.exports = {
      isSuccess: function isSuccess2(response) {
        return SUCCESS_CODES.indexOf(response.status) > -1;
      },
      deleteEmpty: function deleteEmpty(obj) {
        var strict = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        Object.keys(obj).forEach(function(key) {
          if (obj[key] === null || obj[key] === void 0 || strict === true && (obj[key] === "" || obj[key].length === 0 || Object.keys(obj[key]).length === 0)) {
            delete obj[key];
          }
        });
      },
      clone: function clone(obj) {
        var keys = Object.keys(obj);
        var copy = {};
        keys.forEach(function(k) {
          copy[k] = obj[k];
        });
        return copy;
      },
      checkType: function checkType(regex, val) {
        if (regex instanceof RegExp === false) {
          regex = new RegExp(regex);
        }
        return regex.test(Object.prototype.toString.call(val));
      }
    };
  }
});

// node_modules/asap/browser-raw.js
var require_browser_raw = __commonJS({
  "node_modules/asap/browser-raw.js"(exports, module) {
    "use strict";
    module.exports = rawAsap;
    function rawAsap(task) {
      if (!queue.length) {
        requestFlush();
        flushing = true;
      }
      queue[queue.length] = task;
    }
    var queue = [];
    var flushing = false;
    var requestFlush;
    var index = 0;
    var capacity = 1024;
    function flush() {
      while (index < queue.length) {
        var currentIndex = index;
        index = index + 1;
        queue[currentIndex].call();
        if (index > capacity) {
          for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
            queue[scan] = queue[scan + index];
          }
          queue.length -= index;
          index = 0;
        }
      }
      queue.length = 0;
      index = 0;
      flushing = false;
    }
    var scope = typeof global !== "undefined" ? global : self;
    var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
    if (typeof BrowserMutationObserver === "function") {
      requestFlush = makeRequestCallFromMutationObserver(flush);
    } else {
      requestFlush = makeRequestCallFromTimer(flush);
    }
    rawAsap.requestFlush = requestFlush;
    function makeRequestCallFromMutationObserver(callback) {
      var toggle = 1;
      var observer = new BrowserMutationObserver(callback);
      var node = document.createTextNode("");
      observer.observe(node, { characterData: true });
      return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
      };
    }
    function makeRequestCallFromTimer(callback) {
      return function requestCall() {
        var timeoutHandle = setTimeout(handleTimer, 0);
        var intervalHandle = setInterval(handleTimer, 50);
        function handleTimer() {
          clearTimeout(timeoutHandle);
          clearInterval(intervalHandle);
          callback();
        }
      };
    }
    rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
  }
});

// node_modules/promise/lib/core.js
var require_core = __commonJS({
  "node_modules/promise/lib/core.js"(exports, module) {
    "use strict";
    var asap = require_browser_raw();
    function noop() {
    }
    var LAST_ERROR = null;
    var IS_ERROR = {};
    function getThen(obj) {
      try {
        return obj.then;
      } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
      }
    }
    function tryCallOne(fn, a) {
      try {
        return fn(a);
      } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
      }
    }
    function tryCallTwo(fn, a, b) {
      try {
        fn(a, b);
      } catch (ex) {
        LAST_ERROR = ex;
        return IS_ERROR;
      }
    }
    module.exports = Promise2;
    function Promise2(fn) {
      if (typeof this !== "object") {
        throw new TypeError("Promises must be constructed via new");
      }
      if (typeof fn !== "function") {
        throw new TypeError("Promise constructor's argument is not a function");
      }
      this._40 = 0;
      this._65 = 0;
      this._55 = null;
      this._72 = null;
      if (fn === noop)
        return;
      doResolve(fn, this);
    }
    Promise2._37 = null;
    Promise2._87 = null;
    Promise2._61 = noop;
    Promise2.prototype.then = function(onFulfilled, onRejected) {
      if (this.constructor !== Promise2) {
        return safeThen(this, onFulfilled, onRejected);
      }
      var res = new Promise2(noop);
      handle(this, new Handler(onFulfilled, onRejected, res));
      return res;
    };
    function safeThen(self2, onFulfilled, onRejected) {
      return new self2.constructor(function(resolve2, reject2) {
        var res = new Promise2(noop);
        res.then(resolve2, reject2);
        handle(self2, new Handler(onFulfilled, onRejected, res));
      });
    }
    function handle(self2, deferred) {
      while (self2._65 === 3) {
        self2 = self2._55;
      }
      if (Promise2._37) {
        Promise2._37(self2);
      }
      if (self2._65 === 0) {
        if (self2._40 === 0) {
          self2._40 = 1;
          self2._72 = deferred;
          return;
        }
        if (self2._40 === 1) {
          self2._40 = 2;
          self2._72 = [self2._72, deferred];
          return;
        }
        self2._72.push(deferred);
        return;
      }
      handleResolved(self2, deferred);
    }
    function handleResolved(self2, deferred) {
      asap(function() {
        var cb = self2._65 === 1 ? deferred.onFulfilled : deferred.onRejected;
        if (cb === null) {
          if (self2._65 === 1) {
            resolve(deferred.promise, self2._55);
          } else {
            reject(deferred.promise, self2._55);
          }
          return;
        }
        var ret = tryCallOne(cb, self2._55);
        if (ret === IS_ERROR) {
          reject(deferred.promise, LAST_ERROR);
        } else {
          resolve(deferred.promise, ret);
        }
      });
    }
    function resolve(self2, newValue) {
      if (newValue === self2) {
        return reject(
          self2,
          new TypeError("A promise cannot be resolved with itself.")
        );
      }
      if (newValue && (typeof newValue === "object" || typeof newValue === "function")) {
        var then = getThen(newValue);
        if (then === IS_ERROR) {
          return reject(self2, LAST_ERROR);
        }
        if (then === self2.then && newValue instanceof Promise2) {
          self2._65 = 3;
          self2._55 = newValue;
          finale(self2);
          return;
        } else if (typeof then === "function") {
          doResolve(then.bind(newValue), self2);
          return;
        }
      }
      self2._65 = 1;
      self2._55 = newValue;
      finale(self2);
    }
    function reject(self2, newValue) {
      self2._65 = 2;
      self2._55 = newValue;
      if (Promise2._87) {
        Promise2._87(self2, newValue);
      }
      finale(self2);
    }
    function finale(self2) {
      if (self2._40 === 1) {
        handle(self2, self2._72);
        self2._72 = null;
      }
      if (self2._40 === 2) {
        for (var i = 0; i < self2._72.length; i++) {
          handle(self2, self2._72[i]);
        }
        self2._72 = null;
      }
    }
    function Handler(onFulfilled, onRejected, promise) {
      this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
      this.onRejected = typeof onRejected === "function" ? onRejected : null;
      this.promise = promise;
    }
    function doResolve(fn, promise) {
      var done = false;
      var res = tryCallTwo(fn, function(value) {
        if (done)
          return;
        done = true;
        resolve(promise, value);
      }, function(reason) {
        if (done)
          return;
        done = true;
        reject(promise, reason);
      });
      if (!done && res === IS_ERROR) {
        done = true;
        reject(promise, LAST_ERROR);
      }
    }
  }
});

// node_modules/promise/lib/done.js
var require_done = __commonJS({
  "node_modules/promise/lib/done.js"(exports, module) {
    "use strict";
    var Promise2 = require_core();
    module.exports = Promise2;
    Promise2.prototype.done = function(onFulfilled, onRejected) {
      var self2 = arguments.length ? this.then.apply(this, arguments) : this;
      self2.then(null, function(err) {
        setTimeout(function() {
          throw err;
        }, 0);
      });
    };
  }
});

// node_modules/promise/lib/finally.js
var require_finally = __commonJS({
  "node_modules/promise/lib/finally.js"(exports, module) {
    "use strict";
    var Promise2 = require_core();
    module.exports = Promise2;
    Promise2.prototype["finally"] = function(f) {
      return this.then(function(value) {
        return Promise2.resolve(f()).then(function() {
          return value;
        });
      }, function(err) {
        return Promise2.resolve(f()).then(function() {
          throw err;
        });
      });
    };
  }
});

// node_modules/promise/lib/es6-extensions.js
var require_es6_extensions = __commonJS({
  "node_modules/promise/lib/es6-extensions.js"(exports, module) {
    "use strict";
    var Promise2 = require_core();
    module.exports = Promise2;
    var TRUE = valuePromise(true);
    var FALSE = valuePromise(false);
    var NULL = valuePromise(null);
    var UNDEFINED = valuePromise(void 0);
    var ZERO = valuePromise(0);
    var EMPTYSTRING = valuePromise("");
    function valuePromise(value) {
      var p = new Promise2(Promise2._61);
      p._65 = 1;
      p._55 = value;
      return p;
    }
    Promise2.resolve = function(value) {
      if (value instanceof Promise2)
        return value;
      if (value === null)
        return NULL;
      if (value === void 0)
        return UNDEFINED;
      if (value === true)
        return TRUE;
      if (value === false)
        return FALSE;
      if (value === 0)
        return ZERO;
      if (value === "")
        return EMPTYSTRING;
      if (typeof value === "object" || typeof value === "function") {
        try {
          var then = value.then;
          if (typeof then === "function") {
            return new Promise2(then.bind(value));
          }
        } catch (ex) {
          return new Promise2(function(resolve, reject) {
            reject(ex);
          });
        }
      }
      return valuePromise(value);
    };
    Promise2.all = function(arr) {
      var args = Array.prototype.slice.call(arr);
      return new Promise2(function(resolve, reject) {
        if (args.length === 0)
          return resolve([]);
        var remaining = args.length;
        function res(i2, val) {
          if (val && (typeof val === "object" || typeof val === "function")) {
            if (val instanceof Promise2 && val.then === Promise2.prototype.then) {
              while (val._65 === 3) {
                val = val._55;
              }
              if (val._65 === 1)
                return res(i2, val._55);
              if (val._65 === 2)
                reject(val._55);
              val.then(function(val2) {
                res(i2, val2);
              }, reject);
              return;
            } else {
              var then = val.then;
              if (typeof then === "function") {
                var p = new Promise2(then.bind(val));
                p.then(function(val2) {
                  res(i2, val2);
                }, reject);
                return;
              }
            }
          }
          args[i2] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        }
        for (var i = 0; i < args.length; i++) {
          res(i, args[i]);
        }
      });
    };
    Promise2.reject = function(value) {
      return new Promise2(function(resolve, reject) {
        reject(value);
      });
    };
    Promise2.race = function(values) {
      return new Promise2(function(resolve, reject) {
        values.forEach(function(value) {
          Promise2.resolve(value).then(resolve, reject);
        });
      });
    };
    Promise2.prototype["catch"] = function(onRejected) {
      return this.then(null, onRejected);
    };
  }
});

// node_modules/asap/browser-asap.js
var require_browser_asap = __commonJS({
  "node_modules/asap/browser-asap.js"(exports, module) {
    "use strict";
    var rawAsap = require_browser_raw();
    var freeTasks = [];
    var pendingErrors = [];
    var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);
    function throwFirstError() {
      if (pendingErrors.length) {
        throw pendingErrors.shift();
      }
    }
    module.exports = asap;
    function asap(task) {
      var rawTask;
      if (freeTasks.length) {
        rawTask = freeTasks.pop();
      } else {
        rawTask = new RawTask();
      }
      rawTask.task = task;
      rawAsap(rawTask);
    }
    function RawTask() {
      this.task = null;
    }
    RawTask.prototype.call = function() {
      try {
        this.task.call();
      } catch (error) {
        if (asap.onerror) {
          asap.onerror(error);
        } else {
          pendingErrors.push(error);
          requestErrorThrow();
        }
      } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
      }
    };
  }
});

// node_modules/promise/lib/node-extensions.js
var require_node_extensions = __commonJS({
  "node_modules/promise/lib/node-extensions.js"(exports, module) {
    "use strict";
    var Promise2 = require_core();
    var asap = require_browser_asap();
    module.exports = Promise2;
    Promise2.denodeify = function(fn, argumentCount) {
      if (typeof argumentCount === "number" && argumentCount !== Infinity) {
        return denodeifyWithCount(fn, argumentCount);
      } else {
        return denodeifyWithoutCount(fn);
      }
    };
    var callbackFn = "function (err, res) {if (err) { rj(err); } else { rs(res); }}";
    function denodeifyWithCount(fn, argumentCount) {
      var args = [];
      for (var i = 0; i < argumentCount; i++) {
        args.push("a" + i);
      }
      var body = [
        "return function (" + args.join(",") + ") {",
        "var self = this;",
        "return new Promise(function (rs, rj) {",
        "var res = fn.call(",
        ["self"].concat(args).concat([callbackFn]).join(","),
        ");",
        "if (res &&",
        '(typeof res === "object" || typeof res === "function") &&',
        'typeof res.then === "function"',
        ") {rs(res);}",
        "});",
        "};"
      ].join("");
      return Function(["Promise", "fn"], body)(Promise2, fn);
    }
    function denodeifyWithoutCount(fn) {
      var fnLength = Math.max(fn.length - 1, 3);
      var args = [];
      for (var i = 0; i < fnLength; i++) {
        args.push("a" + i);
      }
      var body = [
        "return function (" + args.join(",") + ") {",
        "var self = this;",
        "var args;",
        "var argLength = arguments.length;",
        "if (arguments.length > " + fnLength + ") {",
        "args = new Array(arguments.length + 1);",
        "for (var i = 0; i < arguments.length; i++) {",
        "args[i] = arguments[i];",
        "}",
        "}",
        "return new Promise(function (rs, rj) {",
        "var cb = " + callbackFn + ";",
        "var res;",
        "switch (argLength) {",
        args.concat(["extra"]).map(function(_, index) {
          return "case " + index + ":res = fn.call(" + ["self"].concat(args.slice(0, index)).concat("cb").join(",") + ");break;";
        }).join(""),
        "default:",
        "args[argLength] = cb;",
        "res = fn.apply(self, args);",
        "}",
        "if (res &&",
        '(typeof res === "object" || typeof res === "function") &&',
        'typeof res.then === "function"',
        ") {rs(res);}",
        "});",
        "};"
      ].join("");
      return Function(
        ["Promise", "fn"],
        body
      )(Promise2, fn);
    }
    Promise2.nodeify = function(fn) {
      return function() {
        var args = Array.prototype.slice.call(arguments);
        var callback = typeof args[args.length - 1] === "function" ? args.pop() : null;
        var ctx = this;
        try {
          return fn.apply(this, arguments).nodeify(callback, ctx);
        } catch (ex) {
          if (callback === null || typeof callback == "undefined") {
            return new Promise2(function(resolve, reject) {
              reject(ex);
            });
          } else {
            asap(function() {
              callback.call(ctx, ex);
            });
          }
        }
      };
    };
    Promise2.prototype.nodeify = function(callback, ctx) {
      if (typeof callback != "function")
        return this;
      this.then(function(value) {
        asap(function() {
          callback.call(ctx, null, value);
        });
      }, function(err) {
        asap(function() {
          callback.call(ctx, err);
        });
      });
    };
  }
});

// node_modules/promise/lib/synchronous.js
var require_synchronous = __commonJS({
  "node_modules/promise/lib/synchronous.js"(exports, module) {
    "use strict";
    var Promise2 = require_core();
    module.exports = Promise2;
    Promise2.enableSynchronous = function() {
      Promise2.prototype.isPending = function() {
        return this.getState() == 0;
      };
      Promise2.prototype.isFulfilled = function() {
        return this.getState() == 1;
      };
      Promise2.prototype.isRejected = function() {
        return this.getState() == 2;
      };
      Promise2.prototype.getValue = function() {
        if (this._65 === 3) {
          return this._55.getValue();
        }
        if (!this.isFulfilled()) {
          throw new Error("Cannot get a value of an unfulfilled promise.");
        }
        return this._55;
      };
      Promise2.prototype.getReason = function() {
        if (this._65 === 3) {
          return this._55.getReason();
        }
        if (!this.isRejected()) {
          throw new Error("Cannot get a rejection reason of a non-rejected promise.");
        }
        return this._55;
      };
      Promise2.prototype.getState = function() {
        if (this._65 === 3) {
          return this._55.getState();
        }
        if (this._65 === -1 || this._65 === -2) {
          return 0;
        }
        return this._65;
      };
    };
    Promise2.disableSynchronous = function() {
      Promise2.prototype.isPending = void 0;
      Promise2.prototype.isFulfilled = void 0;
      Promise2.prototype.isRejected = void 0;
      Promise2.prototype.getValue = void 0;
      Promise2.prototype.getReason = void 0;
      Promise2.prototype.getState = void 0;
    };
  }
});

// node_modules/promise/lib/index.js
var require_lib = __commonJS({
  "node_modules/promise/lib/index.js"(exports, module) {
    "use strict";
    module.exports = require_core();
    require_done();
    require_finally();
    require_es6_extensions();
    require_node_extensions();
    require_synchronous();
  }
});

// node_modules/promise/index.js
var require_promise = __commonJS({
  "node_modules/promise/index.js"(exports, module) {
    "use strict";
    module.exports = require_lib();
  }
});

// node_modules/clarifai/dist/ModelVersion.js
var require_ModelVersion = __commonJS({
  "node_modules/clarifai/dist/ModelVersion.js"(exports, module) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var ModelVersion = function ModelVersion2(_config, data) {
      _classCallCheck(this, ModelVersion2);
      this.id = data.id;
      this.created_at = this.createdAt = data.created_at || data.createdAt;
      this.status = data.status;
      this.active_concept_count = data.active_concept_count;
      this.metrics = data.metrics;
      this._config = _config;
      this.rawData = data;
    };
    module.exports = ModelVersion;
  }
});

// node_modules/clarifai/dist/constants.js
var require_constants = __commonJS({
  "node_modules/clarifai/dist/constants.js"(exports, module) {
    "use strict";
    var MAX_BATCH_SIZE = 128;
    var GEO_LIMIT_TYPES = ["withinMiles", "withinKilometers", "withinRadians", "withinDegrees"];
    var SYNC_TIMEOUT = 36e4;
    var MODEL_QUEUED_FOR_TRAINING = "21103";
    var MODEL_TRAINING = "21101";
    var POLLTIME = 2e3;
    module.exports = {
      API: {
        TOKEN_PATH: "/token",
        MODELS_PATH: "/models",
        MODEL_PATH: "/models/$0",
        MODEL_VERSIONS_PATH: "/models/$0/versions",
        MODEL_VERSION_PATH: "/models/$0/versions/$1",
        MODEL_PATCH_PATH: "/models/$0/output_info/data/concepts",
        MODEL_OUTPUT_PATH: "/models/$0/output_info",
        MODEL_VERSION_OUTPUT_PATH: "/models/$0/versions/$1/output_info",
        MODEL_SEARCH_PATH: "/models/searches",
        MODEL_FEEDBACK_PATH: "/models/$0/feedback",
        MODEL_VERSION_FEEDBACK_PATH: "/models/$0/versions/$1/feedback",
        PREDICT_PATH: "/models/$0/outputs",
        VERSION_PREDICT_PATH: "/models/$0/versions/$1/outputs",
        CONCEPTS_PATH: "/concepts",
        CONCEPT_PATH: "/concepts/$0",
        CONCEPT_SEARCH_PATH: "/concepts/searches",
        MODEL_INPUTS_PATH: "/models/$0/inputs",
        MODEL_VERSION_INPUTS_PATH: "/models/$0/versions/$1/inputs",
        MODEL_VERSION_METRICS_PATH: "/models/$0/versions/$1/metrics",
        INPUTS_PATH: "/inputs",
        INPUT_PATH: "/inputs/$0",
        INPUTS_STATUS_PATH: "/inputs/status",
        SEARCH_PATH: "/searches",
        SEARCH_FEEDBACK_PATH: "/searches/feedback",
        WORKFLOWS_PATH: "/workflows",
        WORKFLOW_PATH: "/workflows/$0",
        WORKFLOW_RESULTS_PATH: "/workflows/$0/results"
      },
      ERRORS: {
        paramsRequired: function paramsRequired(param) {
          var paramList = Array.isArray(param) ? param : [param];
          return new Error("The following " + (paramList.length > 1 ? "params are" : "param is") + " required: " + paramList.join(", "));
        },
        MAX_INPUTS: new Error("Number of inputs passed exceeded max of " + MAX_BATCH_SIZE),
        INVALID_GEOLIMIT_TYPE: new Error("Incorrect geo_limit type. Value must be any of the following: " + GEO_LIMIT_TYPES.join(", ")),
        INVALID_DELETE_ARGS: new Error("Wrong arguments passed. You can only delete all models (provide no arguments), delete select models (provide list of ids),\n    delete a single model (providing a single id) or delete a model version (provide a single id and version id)")
      },
      STATUS: {
        MODEL_QUEUED_FOR_TRAINING,
        MODEL_TRAINING
      },
      // var replacement must be given in order
      replaceVars: function replaceVars(path) {
        var vars = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        var newPath = path;
        vars.forEach(function(val, index) {
          if (index === 0) {
            val = encodeURIComponent(val);
          }
          newPath = newPath.replace(new RegExp("\\$" + index, "g"), val);
        });
        return newPath;
      },
      getBasePath: function getBasePath() {
        var apiEndpoint = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "https://api.clarifai.com";
        var userId = arguments[1];
        var appId = arguments[2];
        if (!userId || !appId) {
          return apiEndpoint + "/v2";
        }
        return apiEndpoint + "/v2/users/" + userId + "/apps/" + appId;
      },
      GEO_LIMIT_TYPES,
      MAX_BATCH_SIZE,
      SYNC_TIMEOUT,
      POLLTIME
    };
  }
});

// node_modules/valid-url/index.js
var require_valid_url = __commonJS({
  "node_modules/valid-url/index.js"(exports, module) {
    (function(module2) {
      "use strict";
      module2.exports.is_uri = is_iri;
      module2.exports.is_http_uri = is_http_iri;
      module2.exports.is_https_uri = is_https_iri;
      module2.exports.is_web_uri = is_web_iri;
      module2.exports.isUri = is_iri;
      module2.exports.isHttpUri = is_http_iri;
      module2.exports.isHttpsUri = is_https_iri;
      module2.exports.isWebUri = is_web_iri;
      var splitUri = function(uri) {
        var splitted = uri.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
        return splitted;
      };
      function is_iri(value) {
        if (!value) {
          return;
        }
        if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value))
          return;
        if (/%[^0-9a-f]/i.test(value))
          return;
        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value))
          return;
        var splitted = [];
        var scheme = "";
        var authority = "";
        var path = "";
        var query = "";
        var fragment = "";
        var out = "";
        splitted = splitUri(value);
        scheme = splitted[1];
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];
        if (!(scheme && scheme.length && path.length >= 0))
          return;
        if (authority && authority.length) {
          if (!(path.length === 0 || /^\//.test(path)))
            return;
        } else {
          if (/^\/\//.test(path))
            return;
        }
        if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase()))
          return;
        out += scheme + ":";
        if (authority && authority.length) {
          out += "//" + authority;
        }
        out += path;
        if (query && query.length) {
          out += "?" + query;
        }
        if (fragment && fragment.length) {
          out += "#" + fragment;
        }
        return out;
      }
      function is_http_iri(value, allowHttps) {
        if (!is_iri(value)) {
          return;
        }
        var splitted = [];
        var scheme = "";
        var authority = "";
        var path = "";
        var port = "";
        var query = "";
        var fragment = "";
        var out = "";
        splitted = splitUri(value);
        scheme = splitted[1];
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];
        if (!scheme)
          return;
        if (allowHttps) {
          if (scheme.toLowerCase() != "https")
            return;
        } else {
          if (scheme.toLowerCase() != "http")
            return;
        }
        if (!authority) {
          return;
        }
        if (/:(\d+)$/.test(authority)) {
          port = authority.match(/:(\d+)$/)[0];
          authority = authority.replace(/:\d+$/, "");
        }
        out += scheme + ":";
        out += "//" + authority;
        if (port) {
          out += port;
        }
        out += path;
        if (query && query.length) {
          out += "?" + query;
        }
        if (fragment && fragment.length) {
          out += "#" + fragment;
        }
        return out;
      }
      function is_https_iri(value) {
        return is_http_iri(value, true);
      }
      function is_web_iri(value) {
        return is_http_iri(value) || is_https_iri(value);
      }
    })(module);
  }
});

// node_modules/clarifai/package.json
var require_package = __commonJS({
  "node_modules/clarifai/package.json"(exports, module) {
    module.exports = {
      name: "clarifai",
      version: "2.9.1",
      description: "Official Clarifai Javascript SDK",
      main: "dist/index.js",
      repository: "https://github.com/Clarifai/clarifai-javascript",
      author: "Clarifai Inc.",
      license: "Apache-2.0",
      scripts: {
        jsdoc: "jsdoc src/* -t node_modules/minami -d docs/$npm_package_version && jsdoc src/* -t node_modules/minami -d docs/latest",
        test: "gulp test",
        unittest: "gulp unittest",
        watch: "gulp watch",
        build: "npm run clean && gulp build && npm run jsdoc",
        release: "release-it",
        clean: "gulp cleanbuild"
      },
      dependencies: {
        axios: ">=0.11.1 <2",
        promise: "^7.1.1",
        "valid-url": "^1.0.9"
      },
      devDependencies: {
        "axios-mock-adapter": "^1.16.0",
        "babel-eslint": "^6.1.2",
        "babel-preset-es2015": "^6.14.0",
        "babel-register": "^6.14.0",
        babelify: "^7.3.0",
        del: "^2.0.2",
        envify: "^3.4.0",
        gulp: "^3.9.1",
        "gulp-babel": "^6.1.2",
        "gulp-browserify": "^0.5.1",
        "gulp-eslint": "^2.0.0",
        "gulp-insert": "^0.5.0",
        "gulp-jasmine": "^4.0.0",
        "gulp-notify": "2.2.0",
        "gulp-rename": "^1.2.2",
        "gulp-replace-task": "^0.11.0",
        "gulp-uglify": "^1.4.1",
        "gulp-util": "^3.0.6",
        jsdoc: "^3.4.1",
        minami: "^1.1.1",
        "release-it": "^2.9.0"
      }
    };
  }
});

// node_modules/clarifai/dist/utils.js
var require_utils = __commonJS({
  "node_modules/clarifai/dist/utils.js"(exports, module) {
    "use strict";
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var Promise2 = require_promise();
    var validUrl = require_valid_url();
    var _require = require_constants();
    var GEO_LIMIT_TYPES = _require.GEO_LIMIT_TYPES;
    var ERRORS = _require.ERRORS;
    var _require2 = require_helpers();
    var checkType = _require2.checkType;
    var clone = _require2.clone;
    var _require3 = require_package();
    var VERSION = _require3.version;
    module.exports = {
      wrapToken: function wrapToken2(_config, requestFn) {
        return new Promise2(function(resolve, reject) {
          if (_config.apiKey) {
            var headers = {
              Authorization: "Key " + _config.apiKey,
              "X-Clarifai-Client": "js:" + VERSION
            };
            return requestFn(headers).then(resolve, reject);
          }
          if (_config.sessionToken) {
            var _headers = {
              "X-Clarifai-Session-Token": _config.sessionToken,
              "X-Clarifai-Client": "js:" + VERSION
            };
            return requestFn(_headers).then(resolve, reject);
          }
          _config.token().then(function(token) {
            var headers2 = {
              Authorization: "Bearer " + token.accessToken,
              "X-Clarifai-Client": "js:" + VERSION
            };
            requestFn(headers2).then(resolve, reject);
          }, reject);
        });
      },
      formatModel: function formatModel() {
        var data = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var formatted = {};
        if (data.id === null || data.id === void 0) {
          throw ERRORS.paramsRequired("Model ID");
        }
        formatted.id = data.id;
        if (data.name) {
          formatted.name = data.name;
        }
        formatted.output_info = {};
        if (data.conceptsMutuallyExclusive !== void 0) {
          formatted.output_info.output_config = formatted.output_info.output_config || {};
          formatted.output_info.output_config.concepts_mutually_exclusive = !!data.conceptsMutuallyExclusive;
        }
        if (data.closedEnvironment !== void 0) {
          formatted.output_info.output_config = formatted.output_info.output_config || {};
          formatted.output_info.output_config.closed_environment = !!data.closedEnvironment;
        }
        if (data.concepts) {
          formatted.output_info.data = {
            concepts: data.concepts.map(module.exports.formatConcept)
          };
        }
        return formatted;
      },
      formatInput: function formatInput(data, includeImage) {
        var input = checkType(/String/, data) ? { url: data } : data;
        var formatted = {
          id: input.id || null,
          data: {}
        };
        if (input.concepts) {
          formatted.data.concepts = input.concepts;
        }
        if (input.metadata) {
          formatted.data.metadata = input.metadata;
        }
        if (input.geo) {
          formatted.data.geo = { geo_point: input.geo };
        }
        if (input.regions) {
          formatted.data.regions = input.regions;
        }
        if (includeImage !== false) {
          formatted.data.image = {
            url: input.url,
            base64: input.base64,
            crop: input.crop
          };
          if (data.allowDuplicateUrl) {
            formatted.data.image.allow_duplicate_url = true;
          }
        }
        return formatted;
      },
      formatMediaPredict: function formatMediaPredict(data) {
        var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "image";
        var media = void 0;
        if (checkType(/String/, data)) {
          if (validUrl.isWebUri(data)) {
            media = {
              url: data
            };
          } else {
            media = {
              base64: data
            };
          }
        } else {
          media = Object.assign({}, data);
        }
        var id = void 0;
        if (media.id) {
          id = media.id;
          delete media.id;
        }
        var object = {
          data: _defineProperty({}, type, media)
        };
        if (id) {
          object.id = id;
        }
        return object;
      },
      formatImagesSearch: function formatImagesSearch(image) {
        var imageQuery = void 0;
        var input = { input: { data: {} } };
        var formatted = [];
        if (checkType(/String/, image)) {
          imageQuery = { url: image };
        } else {
          imageQuery = image.url || image.base64 ? {
            image: {
              url: image.url,
              base64: image.base64,
              crop: image.crop
            }
          } : {};
        }
        input.input.data = imageQuery;
        if (image.id) {
          input.input.id = image.id;
          input.input.data = { image: {} };
          if (image.crop) {
            input.input.data.image.crop = image.crop;
          }
        }
        if (image.metadata !== void 0) {
          input.input.data.metadata = image.metadata;
        }
        if (image.geo !== void 0) {
          if (checkType(/Array/, image.geo)) {
            input.input.data.geo = {
              geo_box: image.geo.map(function(p) {
                return { geo_point: p };
              })
            };
          } else if (checkType(/Object/, image.geo)) {
            if (GEO_LIMIT_TYPES.indexOf(image.geo.type) === -1) {
              throw ERRORS.INVALID_GEOLIMIT_TYPE;
            }
            input.input.data.geo = {
              geo_point: {
                latitude: image.geo.latitude,
                longitude: image.geo.longitude
              },
              geo_limit: {
                type: image.geo.type,
                value: image.geo.value
              }
            };
          }
        }
        if (image.type !== "input" && input.input.data.image) {
          if (input.input.data.metadata || input.input.data.geo) {
            var dataCopy = { input: { data: clone(input.input.data) } };
            var imageCopy = { input: { data: clone(input.input.data) } };
            delete dataCopy.input.data.image;
            delete imageCopy.input.data.metadata;
            delete imageCopy.input.data.geo;
            input = [{ output: imageCopy }, dataCopy];
          } else {
            input = [{ output: input }];
          }
        }
        formatted = formatted.concat(input);
        return formatted;
      },
      formatConcept: function formatConcept(concept) {
        var formatted = concept;
        if (checkType(/String/, concept)) {
          formatted = {
            id: concept
          };
        }
        return formatted;
      },
      formatConceptsSearch: function formatConceptsSearch(query) {
        if (checkType(/String/, query)) {
          query = { id: query };
        }
        var v = {};
        var type = query.type === "input" ? "input" : "output";
        delete query.type;
        v[type] = {
          data: {
            concepts: [query]
          }
        };
        return v;
      },
      formatObjectForSnakeCase: function formatObjectForSnakeCase(obj) {
        return Object.keys(obj).reduce(function(o, k) {
          o[k.replace(/([A-Z])/g, function(r) {
            return "_" + r.toLowerCase();
          })] = obj[k];
          return o;
        }, {});
      }
    };
  }
});

// node_modules/clarifai/dist/Model.js
var require_Model = __commonJS({
  "node_modules/clarifai/dist/Model.js"(exports, module) {
    "use strict";
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var axios = require_axios();
    var ModelVersion = require_ModelVersion();
    var _require = require_helpers();
    var isSuccess2 = _require.isSuccess;
    var checkType = _require.checkType;
    var clone = _require.clone;
    var _require2 = require_constants();
    var API = _require2.API;
    var SYNC_TIMEOUT = _require2.SYNC_TIMEOUT;
    var replaceVars = _require2.replaceVars;
    var STATUS = _require2.STATUS;
    var POLLTIME = _require2.POLLTIME;
    var MODEL_QUEUED_FOR_TRAINING = STATUS.MODEL_QUEUED_FOR_TRAINING;
    var MODEL_TRAINING = STATUS.MODEL_TRAINING;
    var _require3 = require_utils();
    var wrapToken2 = _require3.wrapToken;
    var formatMediaPredict = _require3.formatMediaPredict;
    var formatModel = _require3.formatModel;
    var formatObjectForSnakeCase = _require3.formatObjectForSnakeCase;
    var MODEL_VERSIONS_PATH = API.MODEL_VERSIONS_PATH;
    var MODEL_VERSION_PATH = API.MODEL_VERSION_PATH;
    var MODELS_PATH = API.MODELS_PATH;
    var MODEL_FEEDBACK_PATH = API.MODEL_FEEDBACK_PATH;
    var MODEL_VERSION_FEEDBACK_PATH = API.MODEL_VERSION_FEEDBACK_PATH;
    var PREDICT_PATH = API.PREDICT_PATH;
    var VERSION_PREDICT_PATH = API.VERSION_PREDICT_PATH;
    var MODEL_INPUTS_PATH = API.MODEL_INPUTS_PATH;
    var MODEL_VERSION_OUTPUT_PATH = API.MODEL_VERSION_OUTPUT_PATH;
    var MODEL_OUTPUT_PATH = API.MODEL_OUTPUT_PATH;
    var MODEL_VERSION_INPUTS_PATH = API.MODEL_VERSION_INPUTS_PATH;
    var MODEL_VERSION_METRICS_PATH = API.MODEL_VERSION_METRICS_PATH;
    var Model = function() {
      function Model2(_config, data) {
        _classCallCheck(this, Model2);
        this._config = _config;
        this.name = data.name;
        this.id = data.id;
        this.createdAt = data.created_at || data.createdAt;
        this.appId = data.app_id || data.appId;
        this.outputInfo = data.output_info || data.outputInfo;
        if (checkType(/(String)/, data.version)) {
          this.modelVersion = {};
          this.versionId = data.version;
        } else {
          if (data.model_version || data.modelVersion || data.version) {
            this.modelVersion = new ModelVersion(this._config, data.model_version || data.modelVersion || data.version);
          }
          this.versionId = (this.modelVersion || {}).id;
        }
        this.rawData = data;
      }
      _createClass(Model2, [{
        key: "mergeConcepts",
        value: function mergeConcepts() {
          var concepts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          var conceptsArr = Array.isArray(concepts) ? concepts : [concepts];
          return this.update({ action: "merge", concepts: conceptsArr });
        }
        /**
         * Remove concepts from a model
         * @param {object[]}      concepts    List of concept objects with id
         * @return {Promise(Model, error)} A Promise that is fulfilled with a Model instance or rejected with an error
         */
      }, {
        key: "deleteConcepts",
        value: function deleteConcepts() {
          var concepts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          var conceptsArr = Array.isArray(concepts) ? concepts : [concepts];
          return this.update({ action: "remove", concepts: conceptsArr });
        }
        /**
         * Overwrite concepts in a model
         * @param {object[]}      concepts    List of concept objects with id
         * @return {Promise(Model, error)} A Promise that is fulfilled with a Model instance or rejected with an error
         */
      }, {
        key: "overwriteConcepts",
        value: function overwriteConcepts() {
          var concepts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          var conceptsArr = Array.isArray(concepts) ? concepts : [concepts];
          return this.update({ action: "overwrite", concepts: conceptsArr });
        }
        /**
         * Start a model evaluation job
         * @return {Promise(ModelVersion, error)} A Promise that is fulfilled with a ModelVersion instance or rejected with an error
         */
      }, {
        key: "runModelEval",
        value: function runModelEval() {
          var _this = this;
          var url = "" + this._config.basePath + replaceVars(MODEL_VERSION_METRICS_PATH, [this.id, this.versionId]);
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.post(url, {}, { headers }).then(function(response) {
                if (isSuccess2(response)) {
                  resolve(new ModelVersion(_this._config, response.data.model_version));
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
        /**
         * Update a model's output config or concepts
         * @param {object}               model                                 An object with any of the following attrs:
         *   @param {string}               name                                  The new name of the model to update with
         *   @param {boolean}              conceptsMutuallyExclusive             Do you expect to see more than one of the concepts in this model in the SAME image? Set to false (default) if so. Otherwise, set to true.
         *   @param {boolean}              closedEnvironment                     Do you expect to run the trained model on images that do not contain ANY of the concepts in the model? Set to false (default) if so. Otherwise, set to true.
         *   @param {object[]}             concepts                              An array of concept objects or string
         *     @param {object|string}        concepts[].concept                    If string is given, this is interpreted as concept id. Otherwise, if object is given, client expects the following attributes
         *       @param {string}             concepts[].concept.id                   The id of the concept to attach to the model
         *   @param {object[]}             action                                The action to perform on the given concepts. Possible values are 'merge', 'remove', or 'overwrite'. Default: 'merge'
         * @return {Promise(Model, error)} A Promise that is fulfilled with a Model instance or rejected with an error
         */
      }, {
        key: "update",
        value: function update(obj) {
          var _this2 = this;
          var url = "" + this._config.basePath + MODELS_PATH;
          var modelData = [obj];
          var data = { models: modelData.map(function(m) {
            return formatModel(Object.assign(m, { id: _this2.id }));
          }) };
          if (Array.isArray(obj.concepts)) {
            data["action"] = obj.action || "merge";
          }
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.patch(url, data, { headers }).then(function(response) {
                if (isSuccess2(response)) {
                  resolve(new Model2(_this2._config, response.data.models[0]));
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
        /**
         * Create a new model version
         * @param {boolean}       sync     If true, this returns after model has completely trained. If false, this immediately returns default api response.
         * @return {Promise(Model, error)} A Promise that is fulfilled with a Model instance or rejected with an error
         */
      }, {
        key: "train",
        value: function train(sync) {
          var _this3 = this;
          var url = "" + this._config.basePath + replaceVars(MODEL_VERSIONS_PATH, [this.id]);
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.post(url, null, { headers }).then(function(response) {
                if (isSuccess2(response)) {
                  _this3.versionId = response.data.model.model_version.id;
                  if (sync) {
                    var timeStart = Date.now();
                    _this3._pollTrain.bind(_this3)(timeStart, resolve, reject);
                  } else {
                    resolve(new Model2(_this3._config, response.data.model));
                  }
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
      }, {
        key: "_pollTrain",
        value: function _pollTrain(timeStart, resolve, reject) {
          var _this4 = this;
          clearTimeout(this.pollTimeout);
          if (Date.now() - timeStart >= SYNC_TIMEOUT) {
            return reject({
              status: "Error",
              message: "Sync call timed out"
            });
          }
          this.getOutputInfo().then(function(model) {
            var modelStatusCode = model.modelVersion.status.code.toString();
            if (modelStatusCode === MODEL_QUEUED_FOR_TRAINING || modelStatusCode === MODEL_TRAINING) {
              _this4.pollTimeout = setTimeout(function() {
                return _this4._pollTrain(timeStart, resolve, reject);
              }, POLLTIME);
            } else {
              resolve(model);
            }
          }, reject).catch(reject);
        }
        /**
         * Returns model ouputs according to inputs
         * @param {object[]|object|string}       inputs    An array of objects/object/string pointing to an image resource. A string can either be a url or base64 image bytes. Object keys explained below:
         *    @param {object}                      inputs[].image     Object with keys explained below:
         *       @param {string}                     inputs[].image.(url|base64)   Can be a publicly accessibly url or base64 string representing image bytes (required)
         *       @param {number[]}                   inputs[].image.crop           An array containing the percent to be cropped from top, left, bottom and right (optional)
         * @param {object|string} config An object with keys explained below. If a string is passed instead, it will be treated as the language (backwards compatibility)
         *   @param {string} config.language A string code representing the language to return results in (example: 'zh' for simplified Chinese, 'ru' for Russian, 'ja' for Japanese)
         *   @param {boolean} config.video indicates if the input should be processed as a video
         *   @param {object[]} config.selectConcepts An array of concepts to return. Each object in the array will have a form of {name: <CONCEPT_NAME>} or {id: CONCEPT_ID}
         *   @param {float} config.minValue The minimum confidence threshold that a result must meet. From 0.0 to 1.0
         *   @param {number} config.maxConcepts The maximum number of concepts to return
         * @param {boolean} isVideo  Deprecated: indicates if the input should be processed as a video (default false). Deprecated in favor of using config object
         * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error
         */
      }, {
        key: "predict",
        value: function predict(inputs) {
          var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var isVideo = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          if (checkType(/String/, config)) {
            console.warn("passing the language as a string is deprecated, consider using the configuration object instead");
            config = {
              language: config
            };
          }
          if (isVideo) {
            console.warn('"isVideo" argument is deprecated, consider using the configuration object instead');
            config.video = isVideo;
          }
          var video = config.video || false;
          delete config.video;
          if (checkType(/(Object|String)/, inputs)) {
            inputs = [inputs];
          }
          var url = "" + this._config.basePath + (this.versionId ? replaceVars(VERSION_PREDICT_PATH, [this.id, this.versionId]) : replaceVars(PREDICT_PATH, [this.id]));
          return wrapToken2(this._config, function(headers) {
            var params = { inputs: inputs.map(function(input) {
              return formatMediaPredict(input, video ? "video" : "image");
            }) };
            if (config && Object.getOwnPropertyNames(config).length > 0) {
              params["model"] = {
                output_info: {
                  output_config: formatObjectForSnakeCase(config)
                }
              };
            }
            return new Promise(function(resolve, reject) {
              axios.post(url, params, { headers }).then(function(response) {
                var data = clone(response.data);
                data.rawData = clone(response.data);
                resolve(data);
              }, reject);
            });
          });
        }
        /**
         * Returns a version of the model specified by its id
         * @param {string}     versionId   The model's id
         * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error
         */
      }, {
        key: "getVersion",
        value: function getVersion(versionId) {
          var url = "" + this._config.basePath + replaceVars(MODEL_VERSION_PATH, [this.id, versionId]);
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.get(url, { headers }).then(function(response) {
                var data = clone(response.data);
                data.rawData = clone(response.data);
                resolve(data);
              }, reject);
            });
          });
        }
        /**
         * Returns a list of versions of the model
         * @param {object}     options     Object with keys explained below: (optional)
         *   @param {number}     options.page        The page number (optional, default: 1)
         *   @param {number}     options.perPage     Number of images to return per page (optional, default: 20)
         * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error
         */
      }, {
        key: "getVersions",
        value: function getVersions() {
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { page: 1, perPage: 20 };
          var url = "" + this._config.basePath + replaceVars(MODEL_VERSIONS_PATH, [this.id]);
          return wrapToken2(this._config, function(headers) {
            var data = {
              headers,
              params: { "per_page": options.perPage, "page": options.page }
            };
            return new Promise(function(resolve, reject) {
              axios.get(url, data).then(function(response) {
                var data2 = clone(response.data);
                data2.rawData = clone(response.data);
                resolve(data2);
              }, reject);
            });
          });
        }
        /**
         * Returns all the model's output info
         * @return {Promise(Model, error)} A Promise that is fulfilled with a Model instance or rejected with an error
         */
      }, {
        key: "getOutputInfo",
        value: function getOutputInfo() {
          var _this5 = this;
          var url = "" + this._config.basePath + (this.versionId ? replaceVars(MODEL_VERSION_OUTPUT_PATH, [this.id, this.versionId]) : replaceVars(MODEL_OUTPUT_PATH, [this.id]));
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.get(url, { headers }).then(function(response) {
                resolve(new Model2(_this5._config, response.data.model));
              }, reject);
            });
          });
        }
        /**
         * Returns all the model's inputs
         * @param {object}     options     Object with keys explained below: (optional)
         *   @param {number}     options.page        The page number (optional, default: 1)
         *   @param {number}     options.perPage     Number of images to return per page (optional, default: 20)
         * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error
         */
      }, {
        key: "getInputs",
        value: function getInputs() {
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { page: 1, perPage: 20 };
          var url = "" + this._config.basePath + (this.versionId ? replaceVars(MODEL_VERSION_INPUTS_PATH, [this.id, this.versionId]) : replaceVars(MODEL_INPUTS_PATH, [this.id]));
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.get(url, {
                params: { "per_page": options.perPage, "page": options.page },
                headers
              }).then(function(response) {
                var data = clone(response.data);
                data.rawData = clone(response.data);
                resolve(data);
              }, reject);
            });
          });
        }
        /**
         *
         * @param {string} input A string pointing to an image resource. A string must be a url
         * @param {object} config A configuration object consisting of the following required keys
         *   @param {string} config.id The id of the feedback request
         *   @param {object} config.data The feedback data to be sent
         *   @param {object} config.info Meta data related to the feedback request
         * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error
         */
      }, {
        key: "feedback",
        value: function feedback(input, _ref) {
          var id = _ref.id, data = _ref.data, info = _ref.info;
          var url = "" + this._config.basePath + (this.versionId ? replaceVars(MODEL_VERSION_FEEDBACK_PATH, [this.id, this.versionId]) : replaceVars(MODEL_FEEDBACK_PATH, [this.id]));
          var media = formatMediaPredict(input).data;
          info.eventType = "annotation";
          var body = {
            input: {
              id,
              data: Object.assign(media, data),
              "feedback_info": formatObjectForSnakeCase(info)
            }
          };
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.post(url, body, {
                headers
              }).then(function(_ref2) {
                var data2 = _ref2.data;
                var d = clone(data2);
                d.rawData = clone(data2);
                resolve(d);
              }, reject);
            });
          });
        }
      }]);
      return Model2;
    }();
    module.exports = Model;
  }
});

// node_modules/clarifai/dist/Concept.js
var require_Concept = __commonJS({
  "node_modules/clarifai/dist/Concept.js"(exports, module) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Concept = function Concept2(_config, data) {
      _classCallCheck(this, Concept2);
      this.id = data.id;
      this.name = data.name;
      this.createdAt = data.created_at || data.createdAt;
      this.appId = data.app_id || data.appId;
      this.value = data.value || null;
      this._config = _config;
      this.rawData = data;
    };
    module.exports = Concept;
  }
});

// node_modules/clarifai/dist/Concepts.js
var require_Concepts = __commonJS({
  "node_modules/clarifai/dist/Concepts.js"(exports, module) {
    "use strict";
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var axios = require_axios();
    var Concept = require_Concept();
    var _require = require_constants();
    var API = _require.API;
    var replaceVars = _require.replaceVars;
    var CONCEPTS_PATH = API.CONCEPTS_PATH;
    var CONCEPT_PATH = API.CONCEPT_PATH;
    var CONCEPT_SEARCH_PATH = API.CONCEPT_SEARCH_PATH;
    var _require2 = require_utils();
    var wrapToken2 = _require2.wrapToken;
    var formatConcept = _require2.formatConcept;
    var _require3 = require_helpers();
    var isSuccess2 = _require3.isSuccess;
    var checkType = _require3.checkType;
    var Concepts = function() {
      function Concepts2(_config) {
        var _this = this;
        var rawData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        _classCallCheck(this, Concepts2);
        this._config = _config;
        this.rawData = rawData;
        rawData.forEach(function(conceptData, index) {
          _this[index] = new Concept(_this._config, conceptData);
        });
        this.length = rawData.length;
      }
      _createClass(Concepts2, [{
        key: "list",
        value: function list() {
          var _this2 = this;
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { page: 1, perPage: 20 };
          var url = "" + this._config.basePath + CONCEPTS_PATH;
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.get(url, {
                headers,
                params: {
                  "page": options.page,
                  "per_page": options.perPage
                }
              }).then(function(response) {
                if (isSuccess2(response)) {
                  resolve(new Concepts2(_this2._config, response.data.concepts));
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
        /**
         * List a single concept given an id
         * @param {String}     id          The concept's id
         * @return {Promise(Concept, error)} A Promise that is fulfilled with a Concept instance or rejected with an error
         */
      }, {
        key: "get",
        value: function get(id) {
          var _this3 = this;
          var url = "" + this._config.basePath + replaceVars(CONCEPT_PATH, [id]);
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.get(url, { headers }).then(function(response) {
                if (isSuccess2(response)) {
                  resolve(new Concept(_this3._config, response.data.concept));
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
        /**
         * Add a list of concepts given an id and name
         * @param {object|object[]}   concepts       Can be a single media object or an array of media objects
         *   @param  {object|string}    concepts[].concept         If string, this is assumed to be the concept id. Otherwise, an object with the following attributes
         *     @param  {object}           concepts[].concept.id      The new concept's id (Required)
         *     @param  {object}           concepts[].concept.name    The new concept's name
         * @return {Promise(Concepts, error)}             A Promise that is fulfilled with a Concepts instance or rejected with an error
         */
      }, {
        key: "create",
        value: function create() {
          var _this4 = this;
          var concepts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          if (checkType(/(Object|String)/, concepts)) {
            concepts = [concepts];
          }
          var data = {
            "concepts": concepts.map(formatConcept)
          };
          var url = "" + this._config.basePath + CONCEPTS_PATH;
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.post(url, data, { headers }).then(function(response) {
                if (isSuccess2(response)) {
                  resolve(new Concepts2(_this4._config, response.data.concepts));
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
        /**
         * Search for a concept given a name. A wildcard can be given (example: The name "bo*" will match with "boat" and "bow" given those concepts exist
         * @param  {string}   name  The name of the concept to search for
         * @return {Promise(Concepts, error)} A Promise that is fulfilled with a Concepts instance or rejected with an error
         */
      }, {
        key: "search",
        value: function search(name) {
          var _this5 = this;
          var language = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var url = "" + this._config.basePath + CONCEPT_SEARCH_PATH;
          return wrapToken2(this._config, function(headers) {
            var params = {
              "concept_query": { name, language }
            };
            return new Promise(function(resolve, reject) {
              axios.post(url, params, { headers }).then(function(response) {
                if (isSuccess2(response)) {
                  resolve(new Concepts2(_this5._config, response.data.concepts));
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
        /**
         * Update a concepts
         * @param {object|object[]}   concepts       Can be a single concept object or an array of concept objects
         *   @param  {object}           concepts[].concept         A concept object with the following attributes
         *     @param  {object}           concepts[].concept.id      The concept's id (Required)
         *     @param  {object}           concepts[].concept.name    The concept's new name
         * @param {string}            [action=overwrite]  The action to use for the PATCH
         * @return {Promise(Concepts, error)}             A Promise that is fulfilled with a Concepts instance or rejected with an error
         */
      }, {
        key: "update",
        value: function update() {
          var _this6 = this;
          var concepts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          var action = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "overwrite";
          if (!checkType(/Array/, concepts)) {
            concepts = [concepts];
          }
          var data = {
            concepts,
            action
          };
          var url = "" + this._config.basePath + CONCEPTS_PATH;
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.patch(url, data, { headers }).then(function(response) {
                if (isSuccess2(response)) {
                  resolve(new Concepts2(_this6._config, response.data.concepts));
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
      }]);
      return Concepts2;
    }();
    module.exports = Concepts;
  }
});

// node_modules/clarifai/dist/Models.js
var require_Models = __commonJS({
  "node_modules/clarifai/dist/Models.js"(exports, module) {
    "use strict";
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var axios = require_axios();
    var Promise2 = require_promise();
    var Model = require_Model();
    var Concepts = require_Concepts();
    var _require = require_constants();
    var API = _require.API;
    var ERRORS = _require.ERRORS;
    var replaceVars = _require.replaceVars;
    var _require2 = require_helpers();
    var isSuccess2 = _require2.isSuccess;
    var checkType = _require2.checkType;
    var clone = _require2.clone;
    var _require3 = require_utils();
    var wrapToken2 = _require3.wrapToken;
    var formatModel = _require3.formatModel;
    var MODELS_PATH = API.MODELS_PATH;
    var MODEL_PATH = API.MODEL_PATH;
    var MODEL_SEARCH_PATH = API.MODEL_SEARCH_PATH;
    var MODEL_VERSION_PATH = API.MODEL_VERSION_PATH;
    var Models = function() {
      function Models2(_config) {
        var _this = this;
        var rawData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        _classCallCheck(this, Models2);
        this._config = _config;
        this.rawData = rawData;
        rawData.forEach(function(modelData, index) {
          _this[index] = new Model(_this._config, modelData);
        });
        this.length = rawData.length;
      }
      _createClass(Models2, [{
        key: "initModel",
        value: function initModel(model) {
          var _this2 = this;
          var data = {};
          var fn = void 0;
          if (checkType(/String/, model)) {
            data.id = model;
          } else {
            data = model;
          }
          if (data.id) {
            fn = function fn2(resolve, reject) {
              resolve(new Model(_this2._config, data));
            };
          } else {
            fn = function fn2(resolve, reject) {
              _this2.search(data.name, data.type).then(function(models) {
                if (data.version) {
                  resolve(models.rawData.filter(function(model2) {
                    return model2.modelVersion.id === data.version;
                  }));
                } else {
                  resolve(models[0]);
                }
              }, reject).catch(reject);
            };
          }
          return new Promise2(fn);
        }
        /**
         * Calls predict given model info and inputs to predict on
         * @param {string|object}            model       If string, it is assumed to be model id. Otherwise, if object is given, it can have any of the following keys:
         *   @param {string}                   model.id          Model id
         *   @param {string}                   model.name        Model name
         *   @param {string}                   model.version     Model version
         *   @param {string}                   model.language    Model language (only for Clarifai's public models)
         *   @param {string}                   model.type        This can be "concept", "color", "embed", "facedetect", "cluster" or "blur"
         * @param {object[]|object|string}   inputs    An array of objects/object/string pointing to an image resource. A string can either be a url or base64 image bytes. Object keys explained below:
         *    @param {object}                  inputs[].image     Object with keys explained below:
         *       @param {string}                 inputs[].image.(url|base64)  Can be a publicly accessibly url or base64 string representing image bytes (required)
         * @param {boolean} isVideo  indicates if the input should be processed as a video (default false)
         * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error
         */
      }, {
        key: "predict",
        value: function predict(model, inputs) {
          var _this3 = this;
          var config = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          if (checkType(/Boolean/, config)) {
            console.warn('"isVideo" argument is deprecated, consider using the configuration object instead');
            config = {
              video: config
            };
          }
          if (model.language) {
            config.language = model.language;
          }
          return new Promise2(function(resolve, reject) {
            _this3.initModel(model).then(function(modelObj) {
              modelObj.predict(inputs, config).then(resolve, reject).catch(reject);
            }, reject);
          });
        }
        /**
         * Calls train on a model and creates a new model version given model info
         * @param {string|object}            model       If string, it is assumed to be model id. Otherwise, if object is given, it can have any of the following keys:
         *   @param {string}                   model.id          Model id
         *   @param {string}                   model.name        Model name
         *   @param {string}                   model.version     Model version
         *   @param {string}                   model.type        This can be "concept", "color", "embed", "facedetect", "cluster" or "blur"
         * @param {boolean}                  sync        If true, this returns after model has completely trained. If false, this immediately returns default api response.
         * @return {Promise(Model, error)} A Promise that is fulfilled with a Model instance or rejected with an error
         */
      }, {
        key: "train",
        value: function train(model) {
          var _this4 = this;
          var sync = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          return new Promise2(function(resolve, reject) {
            _this4.initModel(model).then(function(model2) {
              model2.train(sync).then(resolve, reject).catch(reject);
            }, reject);
          });
        }
        /**
         *
         * @param {string|object}            model       If string, it is assumed to be model id. Otherwise, if object is given, it can have any of the following keys:
         *   @param {string}                   model.id          Model id
         *   @param {string}                   model.name        Model name
         *   @param {string}                   model.version     Model version
         *   @param {string}                   model.type        This can be "concept", "color", "embed", "facedetect", "cluster" or "blur"
         * @param {string} input A string pointing to an image resource. A string must be a url
         * @param {object} config A configuration object consisting of the following required keys
         *   @param {string} config.id The id of the feedback request
         *   @param {object} config.data The feedback data to be sent
         *   @param {object} config.info Meta data related to the feedback request
         */
      }, {
        key: "feedback",
        value: function feedback(model, input, config) {
          var _this5 = this;
          return new Promise2(function(resolve, reject) {
            _this5.initModel(model).then(function(model2) {
              return model2.feedback(input, config);
            }).then(function(d) {
              return resolve(d);
            }).catch(function(e) {
              return reject(e);
            });
          });
        }
        /**
         * Returns a version of the model specified by its id
         * @param {string|object}            model       If string, it is assumed to be model id. Otherwise, if object is given, it can have any of the following keys:
         *   @param {string}                   model.id          Model id
         *   @param {string}                   model.name        Model name
         *   @param {string}                   model.version     Model version
         *   @param {string}                   model.type        This can be "concept", "color", "embed", "facedetect", "cluster" or "blur"
         * @param {string}     versionId   The model's id
         * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error
         */
      }, {
        key: "getVersion",
        value: function getVersion(model, versionId) {
          var _this6 = this;
          return new Promise2(function(resolve, reject) {
            _this6.initModel(model).then(function(model2) {
              model2.getVersion(versionId).then(resolve, reject).catch(reject);
            }, reject);
          });
        }
        /**
         * Returns a list of versions of the model
         * @param {string|object}            model       If string, it is assumed to be model id. Otherwise, if object is given, it can have any of the following keys:
         *   @param {string}                   model.id          Model id
         *   @param {string}                   model.name        Model name
         *   @param {string}                   model.version     Model version
         *   @param {string}                   model.type        This can be "concept", "color", "embed", "facedetect", "cluster" or "blur"
         * @param {object}                   options     Object with keys explained below: (optional)
         *   @param {number}                   options.page        The page number (optional, default: 1)
         *   @param {number}                   options.perPage     Number of images to return per page (optional, default: 20)
         * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error
         */
      }, {
        key: "getVersions",
        value: function getVersions(model) {
          var _this7 = this;
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { page: 1, perPage: 20 };
          return new Promise2(function(resolve, reject) {
            _this7.initModel(model).then(function(model2) {
              model2.getVersions(options).then(resolve, reject).catch(reject);
            }, reject);
          });
        }
        /**
         * Returns all the model's output info
         * @param {string|object}            model       If string, it is assumed to be model id. Otherwise, if object is given, it can have any of the following keys:
         *   @param {string}                   model.id          Model id
         *   @param {string}                   model.name        Model name
         *   @param {string}                   model.version     Model version
         *   @param {string}                   model.type        This can be "concept", "color", "embed", "facedetect", "cluster" or "blur"
         * @return {Promise(Model, error)} A Promise that is fulfilled with a Model instance or rejected with an error
         */
      }, {
        key: "getOutputInfo",
        value: function getOutputInfo(model) {
          var _this8 = this;
          return new Promise2(function(resolve, reject) {
            _this8.initModel(model).then(function(model2) {
              model2.getOutputInfo().then(resolve, reject).catch(reject);
            }, reject);
          });
        }
        /**
         * Returns all the models
         * @param {Object}     options     Object with keys explained below: (optional)
         *   @param {Number}     options.page        The page number (optional, default: 1)
         *   @param {Number}     options.perPage     Number of images to return per page (optional, default: 20)
         * @return {Promise(Models, error)} A Promise that is fulfilled with an instance of Models or rejected with an error
         */
      }, {
        key: "list",
        value: function list() {
          var _this9 = this;
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { page: 1, perPage: 20 };
          var url = "" + this._config.basePath + MODELS_PATH;
          return wrapToken2(this._config, function(headers) {
            return new Promise2(function(resolve, reject) {
              axios.get(url, {
                params: { "per_page": options.perPage, "page": options.page },
                headers
              }).then(function(response) {
                if (isSuccess2(response)) {
                  resolve(new Models2(_this9._config, response.data.models));
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
        /**
         * Create a model
         * @param {string|object}                  model                                  If string, it is assumed to be the model id. Otherwise, if object is given, it can have any of the following keys:
         *   @param {string}                         model.id                               Model id
         *   @param {string}                         model.name                             Model name
         * @param {object[]|string[]|Concepts[]}   conceptsData                           List of objects with ids, concept id strings or an instance of Concepts object
         * @param {Object}                         options                                Object with keys explained below:
         *   @param {boolean}                        options.conceptsMutuallyExclusive      Do you expect to see more than one of the concepts in this model in the SAME image? Set to false (default) if so. Otherwise, set to true.
         *   @param {boolean}                        options.closedEnvironment              Do you expect to run the trained model on images that do not contain ANY of the concepts in the model? Set to false (default) if so. Otherwise, set to true.
         * @return {Promise(Model, error)} A Promise that is fulfilled with an instance of Model or rejected with an error
         */
      }, {
        key: "create",
        value: function create(model) {
          var _this10 = this;
          var conceptsData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var concepts = conceptsData instanceof Concepts ? conceptsData.toObject("id") : conceptsData.map(function(concept) {
            var val = concept;
            if (checkType(/String/, concept)) {
              val = { "id": concept };
            }
            return val;
          });
          var modelObj = model;
          if (checkType(/String/, model)) {
            modelObj = { id: model, name: model };
          }
          if (modelObj.id === void 0) {
            throw ERRORS.paramsRequired("Model ID");
          }
          var url = "" + this._config.basePath + MODELS_PATH;
          var data = { model: modelObj };
          data["model"]["output_info"] = {
            "data": {
              concepts
            },
            "output_config": {
              "concepts_mutually_exclusive": !!options.conceptsMutuallyExclusive,
              "closed_environment": !!options.closedEnvironment
            }
          };
          return wrapToken2(this._config, function(headers) {
            return new Promise2(function(resolve, reject) {
              axios.post(url, data, { headers }).then(function(response) {
                if (isSuccess2(response)) {
                  resolve(new Model(_this10._config, response.data.model));
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
        /**
         * Returns a model specified by ID
         * @param {String}     id          The model's id
         * @return {Promise(Model, error)} A Promise that is fulfilled with an instance of Model or rejected with an error
         */
      }, {
        key: "get",
        value: function get(id) {
          var _this11 = this;
          var url = "" + this._config.basePath + replaceVars(MODEL_PATH, [id]);
          return wrapToken2(this._config, function(headers) {
            return new Promise2(function(resolve, reject) {
              axios.get(url, { headers }).then(function(response) {
                if (isSuccess2(response)) {
                  resolve(new Model(_this11._config, response.data.model));
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
        /**
         * Update a model's or a list of models' output config or concepts
         * @param {object|object[]}      models                                 Can be a single model object or list of model objects with the following attrs:
         *   @param {string}               models.id                                    The id of the model to apply changes to (Required)
         *   @param {string}               models.name                                  The new name of the model to update with
         *   @param {boolean}              models.conceptsMutuallyExclusive             Do you expect to see more than one of the concepts in this model in the SAME image? Set to false (default) if so. Otherwise, set to true.
         *   @param {boolean}              models.closedEnvironment                     Do you expect to run the trained model on images that do not contain ANY of the concepts in the model? Set to false (default) if so. Otherwise, set to true.
         *   @param {object[]}             models.concepts                              An array of concept objects or string
         *     @param {object|string}        models.concepts[].concept                    If string is given, this is interpreted as concept id. Otherwise, if object is given, client expects the following attributes
         *       @param {string}             models.concepts[].concept.id                   The id of the concept to attach to the model
         *   @param {object[]}             models.action                                The action to perform on the given concepts. Possible values are 'merge', 'remove', or 'overwrite'. Default: 'merge'
         * @return {Promise(Models, error)} A Promise that is fulfilled with an instance of Models or rejected with an error
         */
      }, {
        key: "update",
        value: function update(models) {
          var _this12 = this;
          var url = "" + this._config.basePath + MODELS_PATH;
          var modelsList = Array.isArray(models) ? models : [models];
          var data = { models: modelsList.map(formatModel) };
          data["action"] = models.action || "merge";
          return wrapToken2(this._config, function(headers) {
            return new Promise2(function(resolve, reject) {
              axios.patch(url, data, { headers }).then(function(response) {
                if (isSuccess2(response)) {
                  resolve(new Models2(_this12._config, response.data.models));
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
        /**
         * Update model by merging concepts
         * @param {object|object[]}      model                                 Can be a single model object or list of model objects with the following attrs:
         *   @param {string}               model.id                                    The id of the model to apply changes to (Required)
         *   @param {object[]}             model.concepts                              An array of concept objects or string
         *     @param {object|string}        model.concepts[].concept                    If string is given, this is interpreted as concept id. Otherwise, if object is given, client expects the following attributes
         *       @param {string}             model.concepts[].concept.id                   The id of the concept to attach to the model
         */
      }, {
        key: "mergeConcepts",
        value: function mergeConcepts() {
          var model = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          model.action = "merge";
          return this.update(model);
        }
        /**
         * Update model by removing concepts
         * @param {object|object[]}      model                                 Can be a single model object or list of model objects with the following attrs:
         *   @param {string}               model.id                                    The id of the model to apply changes to (Required)
         *   @param {object[]}             model.concepts                              An array of concept objects or string
         *     @param {object|string}        model.concepts[].concept                    If string is given, this is interpreted as concept id. Otherwise, if object is given, client expects the following attributes
         *       @param {string}             model.concepts[].concept.id                   The id of the concept to attach to the model
         */
      }, {
        key: "deleteConcepts",
        value: function deleteConcepts() {
          var model = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          model.action = "remove";
          return this.update(model);
        }
        /**
         * Update model by overwriting concepts
         * @param {object|object[]}      model                                 Can be a single model object or list of model objects with the following attrs:
         *   @param {string}               model.id                                    The id of the model to apply changes to (Required)
         *   @param {object[]}             model.concepts                              An array of concept objects or string
         *     @param {object|string}        model.concepts[].concept                    If string is given, this is interpreted as concept id. Otherwise, if object is given, client expects the following attributes
         *       @param {string}             model.concepts[].concept.id                   The id of the concept to attach to the model
         */
      }, {
        key: "overwriteConcepts",
        value: function overwriteConcepts() {
          var model = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          model.action = "overwrite";
          return this.update(model);
        }
        /**
         * Deletes all models (if no ids and versionId given) or a model (if given id) or a model version (if given id and verion id)
         * @param {String|String[]}      ids         Can be a single string or an array of strings representing the model ids
         * @param {String}               versionId   The model's version id
         * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error
         */
      }, {
        key: "delete",
        value: function _delete(ids) {
          var versionId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var request = void 0, url = void 0, data = void 0;
          var id = ids;
          if (checkType(/String/, ids) || checkType(/Array/, ids) && ids.length === 1) {
            if (versionId) {
              url = "" + this._config.basePath + replaceVars(MODEL_VERSION_PATH, [id, versionId]);
            } else {
              url = "" + this._config.basePath + replaceVars(MODEL_PATH, [id]);
            }
            request = wrapToken2(this._config, function(headers) {
              return new Promise2(function(resolve, reject) {
                axios.delete(url, { headers }).then(function(response) {
                  var data2 = clone(response.data);
                  data2.rawData = clone(response.data);
                  resolve(data2);
                }, reject);
              });
            });
          } else {
            if (!ids && !versionId) {
              url = "" + this._config.basePath + MODELS_PATH;
              data = { "delete_all": true };
            } else if (!versionId && ids.length > 1) {
              url = "" + this._config.basePath + MODELS_PATH;
              data = { ids };
            } else {
              throw ERRORS.INVALID_DELETE_ARGS;
            }
            request = wrapToken2(this._config, function(headers) {
              return new Promise2(function(resolve, reject) {
                axios({
                  method: "delete",
                  url,
                  data,
                  headers
                }).then(function(response) {
                  var data2 = clone(response.data);
                  data2.rawData = clone(response.data);
                  resolve(data2);
                }, reject);
              });
            });
          }
          return request;
        }
        /**
         * Search for models by name or type
         * @param {String}     name        The model name
         * @param {String}     type        This can be "concept", "color", "embed", "facedetect", "cluster" or "blur"
         * @return {Promise(models, error)} A Promise that is fulfilled with an instance of Models or rejected with an error
         */
      }, {
        key: "search",
        value: function search(name) {
          var _this13 = this;
          var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var url = "" + this._config.basePath + MODEL_SEARCH_PATH;
          return wrapToken2(this._config, function(headers) {
            var params = {
              "model_query": {
                name,
                type
              }
            };
            return new Promise2(function(resolve, reject) {
              axios.post(url, params, { headers }).then(function(response) {
                if (isSuccess2(response)) {
                  resolve(new Models2(_this13._config, response.data.models));
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
      }]);
      return Models2;
    }();
    module.exports = Models;
  }
});

// node_modules/clarifai/dist/Region.js
var require_Region = __commonJS({
  "node_modules/clarifai/dist/Region.js"(exports, module) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Region = function Region2(_config, data) {
      _classCallCheck(this, Region2);
      this.id = data.id;
      this.top = data.region_info.bounding_box.top_row;
      this.left = data.region_info.bounding_box.left_col;
      this.bottom = data.region_info.bounding_box.bottom_row;
      this.right = data.region_info.bounding_box.right_col;
    };
    module.exports = Region;
  }
});

// node_modules/clarifai/dist/Regions.js
var require_Regions = __commonJS({
  "node_modules/clarifai/dist/Regions.js"(exports, module) {
    "use strict";
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Region = require_Region();
    var Regions = function() {
      function Regions2(_config) {
        var _this = this;
        var rawData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        _classCallCheck(this, Regions2);
        this._config = _config;
        this.rawData = rawData;
        rawData.forEach(function(regionData, index) {
          _this[index] = new Region(_this._config, regionData);
        });
        this.length = rawData.length;
      }
      _createClass(Regions2, [{
        key: Symbol.iterator,
        value: function value() {
          var _this2 = this;
          var index = -1;
          return {
            next: function next() {
              return { value: _this2[++index], done: index >= _this2.length };
            }
          };
        }
      }]);
      return Regions2;
    }();
    module.exports = Regions;
  }
});

// node_modules/clarifai/dist/Input.js
var require_Input = __commonJS({
  "node_modules/clarifai/dist/Input.js"(exports, module) {
    "use strict";
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var axios = require_axios();
    var Concepts = require_Concepts();
    var Regions = require_Regions();
    var _require = require_constants();
    var API = _require.API;
    var INPUTS_PATH = API.INPUTS_PATH;
    var Input = function() {
      function Input2(_config, data) {
        _classCallCheck(this, Input2);
        this.id = data.id;
        this.createdAt = data.created_at || data.createdAt;
        this.imageUrl = data.data.image.url;
        this.concepts = new Concepts(_config, data.data.concepts);
        this.regions = new Regions(_config, data.data.regions || []);
        this.score = data.score;
        this.metadata = data.data.metadata;
        if (data.data.geo && data.data.geo["geo_point"]) {
          this.geo = { geoPoint: data.data.geo["geo_point"] };
        }
        this.rawData = data;
        this._config = _config;
      }
      _createClass(Input2, [{
        key: "mergeConcepts",
        value: function mergeConcepts(concepts, metadata) {
          return this._update("merge", concepts, metadata);
        }
        /**
         * Delete concept from an input
         * @param {object[]}         concepts    Object with keys explained below:
         *   @param {object}           concepts[].concept
         *     @param {string}           concepts[].concept.id        The concept id (required)
         *     @param {boolean}          concepts[].concept.value     Whether or not the input is a positive (true) or negative (false) example of the concept (default: true)
         * @param {object}           metadata                      Object with key values to attach to the input (optional)
         * @return {Promise(Input, error)} A Promise that is fulfilled with an instance of Input or rejected with an error
         */
      }, {
        key: "deleteConcepts",
        value: function deleteConcepts(concepts, metadata) {
          return this._update("remove", concepts, metadata);
        }
        /**
         * Overwrite inputs
         * @param {object[]}         concepts                      Array of object with keys explained below:
         *   @param {object}           concepts[].concept
         *     @param {string}           concepts[].concept.id         The concept id (required)
         *     @param {boolean}          concepts[].concept.value      Whether or not the input is a positive (true) or negative (false) example of the concept (default: true)
         * @param {object}           metadata                      Object with key values to attach to the input (optional)
         * @return {Promise(Input, error)} A Promise that is fulfilled with an instance of Input or rejected with an error
         */
      }, {
        key: "overwriteConcepts",
        value: function overwriteConcepts(concepts, metadata) {
          return this._update("overwrite", concepts, metadata);
        }
      }, {
        key: "_update",
        value: function _update(action) {
          var concepts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          var metadata = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          var url = "" + this._config.basePath + INPUTS_PATH;
          var inputData = {};
          if (concepts.length) {
            inputData.concepts = concepts;
          }
          if (metadata !== null) {
            inputData.metadata = metadata;
          }
          var data = {
            action,
            inputs: [{
              id: this.id,
              data: inputData
            }]
          };
          return wrapToken(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              return axios.patch(url, data, { headers }).then(function(response) {
                if (isSuccess(response)) {
                  resolve(new Input2(response.data.input));
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
      }]);
      return Input2;
    }();
    module.exports = Input;
  }
});

// node_modules/clarifai/dist/Inputs.js
var require_Inputs = __commonJS({
  "node_modules/clarifai/dist/Inputs.js"(exports, module) {
    "use strict";
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var axios = require_axios();
    var Input = require_Input();
    var _require = require_constants();
    var API = _require.API;
    var ERRORS = _require.ERRORS;
    var MAX_BATCH_SIZE = _require.MAX_BATCH_SIZE;
    var replaceVars = _require.replaceVars;
    var INPUT_PATH = API.INPUT_PATH;
    var INPUTS_PATH = API.INPUTS_PATH;
    var INPUTS_STATUS_PATH = API.INPUTS_STATUS_PATH;
    var SEARCH_PATH = API.SEARCH_PATH;
    var SEARCH_FEEDBACK_PATH = API.SEARCH_FEEDBACK_PATH;
    var _require2 = require_utils();
    var wrapToken2 = _require2.wrapToken;
    var formatInput = _require2.formatInput;
    var formatImagesSearch = _require2.formatImagesSearch;
    var formatConceptsSearch = _require2.formatConceptsSearch;
    var _require3 = require_helpers();
    var isSuccess2 = _require3.isSuccess;
    var checkType = _require3.checkType;
    var clone = _require3.clone;
    var Inputs = function() {
      function Inputs2(_config) {
        var _this = this;
        var rawData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        _classCallCheck(this, Inputs2);
        this.rawData = rawData;
        rawData.forEach(function(inputData, index) {
          if (inputData.input && inputData.score) {
            inputData.input.score = inputData.score;
            inputData = inputData.input;
          }
          _this[index] = new Input(_this._config, inputData);
        });
        this.length = rawData.length;
        this._config = _config;
      }
      _createClass(Inputs2, [{
        key: "list",
        value: function list() {
          var _this2 = this;
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { page: 1, perPage: 20 };
          var url = "" + this._config.basePath + INPUTS_PATH;
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.get(url, {
                headers,
                params: {
                  page: options.page,
                  per_page: options.perPage
                }
              }).then(function(response) {
                if (isSuccess2(response)) {
                  resolve(new Inputs2(_this2._config, response.data.inputs));
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
        /**
         * Adds an input or multiple inputs
         * @param {object|object[]}        inputs                                Can be a single media object or an array of media objects (max of 128 inputs/call; passing > 128 will throw an exception)
         *   @param {object|string}          inputs[].input                        If string, is given, this is assumed to be an image url
         *     @param {string}                 inputs[].input.(url|base64)           Can be a publicly accessibly url or base64 string representing image bytes (required)
         *     @param {string}                 inputs[].input.id                     ID of input (optional)
         *     @param {number[]}               inputs[].input.crop                   An array containing the percent to be cropped from top, left, bottom and right (optional)
         *     @param {boolean}               inputs[].input.allowDuplicateUrl       Whether to allow duplicate URL
         *     @param {object[]}               inputs[].input.metadata               Object with key and values pair (value can be string, array or other objects) to attach to the input (optional)
         *     @param {object}                 inputs[].input.geo                    Object with latitude and longitude coordinates to associate with an input. Can be used in search query as the proximity of an input to a reference point (optional)
         *       @param {number}                 inputs[].input.geo.latitude           +/- latitude val of geodata
         *       @param {number}                 inputs[].input.geo.longitude          +/- longitude val of geodata
         *     @param {object[]}               inputs[].input.concepts               An array of concepts to attach to media object (optional)
         *       @param {object|string}          inputs[].input.concepts[].concept     If string, is given, this is assumed to be concept id with value equals true
         *         @param {string}                 inputs[].input.concepts[].concept.id          The concept id (required)
         *         @param {boolean}                inputs[].input.concepts[].concept.value       Whether or not the input is a positive (true) or negative (false) example of the concept (default: true)
         * @return {Promise(Inputs, error)} A Promise that is fulfilled with an instance of Inputs or rejected with an error
         */
      }, {
        key: "create",
        value: function create(inputs) {
          var _this3 = this;
          if (checkType(/(String|Object)/, inputs)) {
            inputs = [inputs];
          }
          var url = "" + this._config.basePath + INPUTS_PATH;
          if (inputs.length > MAX_BATCH_SIZE) {
            throw ERRORS.MAX_INPUTS;
          }
          return wrapToken2(this._config, function(headers) {
            var data = {
              inputs: inputs.map(formatInput)
            };
            return new Promise(function(resolve, reject) {
              axios.post(url, data, { headers }).then(function(response) {
                if (isSuccess2(response)) {
                  resolve(new Inputs2(_this3._config, response.data.inputs));
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
        /**
         * Get input by id
         * @param {String}    id  The input id
         * @return {Promise(Input, error)} A Promise that is fulfilled with an instance of Input or rejected with an error
         */
      }, {
        key: "get",
        value: function get(id) {
          var _this4 = this;
          var url = "" + this._config.basePath + replaceVars(INPUT_PATH, [id]);
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.get(url, { headers }).then(function(response) {
                if (isSuccess2(response)) {
                  resolve(new Input(_this4._config, response.data.input));
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
        /**
         * Delete an input or a list of inputs by id or all inputs if no id is passed
         * @param {string|string[]}    id           The id of input to delete (optional)
         * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error
         */
      }, {
        key: "delete",
        value: function _delete() {
          var id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          var val = void 0;
          if (checkType(/String/, id)) {
            var url = "" + this._config.basePath + replaceVars(INPUT_PATH, [id]);
            val = wrapToken2(this._config, function(headers) {
              return axios.delete(url, { headers });
            });
          } else {
            val = this._deleteInputs(id);
          }
          return val;
        }
      }, {
        key: "_deleteInputs",
        value: function _deleteInputs() {
          var id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          var url = "" + this._config.basePath + INPUTS_PATH;
          return wrapToken2(this._config, function(headers) {
            var data = id === null ? { delete_all: true } : { ids: id };
            return axios({
              url,
              method: "delete",
              headers,
              data
            });
          });
        }
        /**
         * Merge concepts to inputs in bulk
         * @param {object[]}         inputs    List of concepts to update (max of 128 inputs/call; passing > 128 will throw an exception)
         *   @param {object}           inputs[].input
         *     @param {string}           inputs[].input.id        The id of the input to update
         *     @param {string}           inputs[].input.concepts  Object with keys explained below:
         *       @param {object}           inputs[].input.concepts[].concept
         *         @param {string}           inputs[].input.concepts[].concept.id        The concept id (required)
         *         @param {boolean}          inputs[].input.concepts[].concept.value     Whether or not the input is a positive (true) or negative (false) example of the concept (default: true)
         * @return {Promise(Inputs, error)} A Promise that is fulfilled with an instance of Inputs or rejected with an error
         */
      }, {
        key: "mergeConcepts",
        value: function mergeConcepts(inputs) {
          inputs.action = "merge";
          return this.update(inputs);
        }
        /**
         * Delete concepts to inputs in bulk
         * @param {object[]}         inputs    List of concepts to update (max of 128 inputs/call; passing > 128 will throw an exception)
         *   @param {object}           inputs[].input
         *     @param {string}           inputs[].input.id                           The id of the input to update
         *     @param {string}           inputs[].input.concepts                     Object with keys explained below:
         *       @param {object}           inputs[].input.concepts[].concept
         *         @param {string}           inputs[].input.concepts[].concept.id        The concept id (required)
         *         @param {boolean}          inputs[].input.concepts[].concept.value     Whether or not the input is a positive (true) or negative (false) example of the concept (default: true)
         * @return {Promise(Inputs, error)} A Promise that is fulfilled with an instance of Inputs or rejected with an error
         */
      }, {
        key: "deleteConcepts",
        value: function deleteConcepts(inputs) {
          inputs.action = "remove";
          return this.update(inputs);
        }
        /**
         * Overwrite inputs in bulk
         * @param {object[]}         inputs    List of concepts to update (max of 128 inputs/call; passing > 128 will throw an exception)
         *   @param {object}           inputs[].input
         *     @param {string}           inputs[].input.id                           The id of the input to update
         *     @param {string}           inputs[].input.concepts                     Object with keys explained below:
         *       @param {object}           inputs[].input.concepts[].concept
         *         @param {string}           inputs[].input.concepts[].concept.id        The concept id (required)
         *         @param {boolean}          inputs[].input.concepts[].concept.value     Whether or not the input is a positive (true) or negative (false) example of the concept (default: true)
         * @return {Promise(Inputs, error)} A Promise that is fulfilled with an instance of Inputs or rejected with an error
         */
      }, {
        key: "overwriteConcepts",
        value: function overwriteConcepts(inputs) {
          inputs.action = "overwrite";
          return this.update(inputs);
        }
        /**
         * @param {object[]}         inputs    List of inputs to update (max of 128 inputs/call; passing > 128 will throw an exception)
         *   @param {object}           inputs[].input
         *     @param {string}           inputs[].input.id                           The id of the input to update
         *     @param {object}           inputs[].input.metadata                     Object with key values to attach to the input (optional)
         *     @param {object}           inputs[].input.geo                          Object with latitude and longitude coordinates to associate with an input. Can be used in search query as the proximity of an input to a reference point (optional)
         *       @param {number}           inputs[].input.geo.latitude                 +/- latitude val of geodata
         *       @param {number}           inputs[].input.geo.longitude                +/- longitude val of geodata
         *     @param {string}           inputs[].input.concepts                     Object with keys explained below (optional):
         *       @param {object}           inputs[].input.concepts[].concept
         *         @param {string}           inputs[].input.concepts[].concept.id        The concept id (required)
         *         @param {boolean}          inputs[].input.concepts[].concept.value     Whether or not the input is a positive (true) or negative (false) example of the concept (default: true)
         * @return {Promise(Inputs, error)} A Promise that is fulfilled with an instance of Inputs or rejected with an error
         */
      }, {
        key: "update",
        value: function update(inputs) {
          var _this5 = this;
          var url = "" + this._config.basePath + INPUTS_PATH;
          var inputsList = Array.isArray(inputs) ? inputs : [inputs];
          if (inputsList.length > MAX_BATCH_SIZE) {
            throw ERRORS.MAX_INPUTS;
          }
          var data = {
            action: inputs.action,
            inputs: inputsList.map(function(input) {
              return formatInput(input, false);
            })
          };
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.patch(url, data, { headers }).then(function(response) {
                if (isSuccess2(response)) {
                  resolve(new Inputs2(_this5._config, response.data.inputs));
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
        /**
         * Search for inputs or outputs based on concepts or images
         *   @param {object[]}               queries          List of all predictions to match with
         *     @param {object}                 queries[].concept            An object with the following keys:
         *       @param {string}                 queries[].concept.id          The concept id
         *       @param {string}                 queries[].concept.type        Search over 'input' to get input matches to criteria or 'output' to get inputs that are visually similar to the criteria (default: 'output')
         *       @param {string}                 queries[].concept.name        The concept name
         *       @param {boolean}                queries[].concept.value       Indicates whether or not the term should match with the prediction returned (default: true)
         *     @param {object}                 queries[].input              An image object that contains the following keys:
         *       @param {string}                 queries[].input.id            The input id
         *       @param {string}                 queries[].input.type          Search over 'input' to get input matches to criteria or 'output' to get inputs that are visually similar to the criteria (default: 'output')
         *       @param {string}                 queries[].input.(base64|url)  Can be a publicly accessibly url or base64 string representing image bytes (required)
         *       @param {number[]}               queries[].input.crop          An array containing the percent to be cropped from top, left, bottom and right (optional)
         *       @param {object}                 queries[].input.metadata      An object with key and value specified by user to refine search with (optional)
         * @param {Object}                   options       Object with keys explained below: (optional)
         *    @param {Number}                  options.page          The page number (optional, default: 1)
         *    @param {Number}                  options.perPage       Number of images to return per page (optional, default: 20)
         * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error
         */
      }, {
        key: "search",
        value: function search() {
          var queries = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { page: 1, perPage: 20 };
          var formattedAnds = [];
          var url = "" + this._config.basePath + SEARCH_PATH;
          var data = {
            query: {
              ands: []
            },
            pagination: {
              page: options.page,
              per_page: options.perPage
            }
          };
          if (!Array.isArray(queries)) {
            queries = [queries];
          }
          if (queries.length > 0) {
            queries.forEach(function(query) {
              if (query.input) {
                formattedAnds = formattedAnds.concat(formatImagesSearch(query.input));
              } else if (query.concept) {
                formattedAnds = formattedAnds.concat(formatConceptsSearch(query.concept));
              }
            });
            data.query.ands = formattedAnds;
          }
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.post(url, data, { headers }).then(function(response) {
                if (isSuccess2(response)) {
                  var _data = clone(response.data);
                  _data.rawData = clone(response.data);
                  resolve(_data);
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
      }, {
        key: "searchFeedback",
        value: function searchFeedback(inputID, searchID, endUserID, sessionID) {
          var url = "" + this._config.basePath + SEARCH_FEEDBACK_PATH;
          var body = {
            input: {
              id: inputID,
              feedback_info: {
                event_type: "search_click",
                search_id: searchID,
                end_user_id: endUserID,
                session_id: sessionID
              }
            }
          };
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.post(url, body, {
                headers
              }).then(function(_ref) {
                var data = _ref.data;
                var d = clone(data);
                d.rawData = clone(data);
                resolve(d);
              }, reject);
            });
          });
        }
        /**
         * Get inputs status (number of uploaded, in process or failed inputs)
         * @return {Promise(response, error)} A Promise that is fulfilled with the API response or rejected with an error
         */
      }, {
        key: "getStatus",
        value: function getStatus() {
          var url = "" + this._config.basePath + INPUTS_STATUS_PATH;
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.get(url, { headers }).then(function(response) {
                if (isSuccess2(response)) {
                  var data = clone(response.data);
                  data.rawData = clone(response.data);
                  resolve(data);
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
      }]);
      return Inputs2;
    }();
    module.exports = Inputs;
  }
});

// node_modules/clarifai/dist/Workflow.js
var require_Workflow = __commonJS({
  "node_modules/clarifai/dist/Workflow.js"(exports, module) {
    "use strict";
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _utils = require_utils();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var axios = require_axios();
    var _require = require_constants();
    var API = _require.API;
    var replaceVars = _require.replaceVars;
    var WORKFLOWS_PATH = API.WORKFLOWS_PATH;
    var WORKFLOW_PATH = API.WORKFLOW_PATH;
    var WORKFLOW_RESULTS_PATH = API.WORKFLOW_RESULTS_PATH;
    var _require2 = require_utils();
    var wrapToken2 = _require2.wrapToken;
    var formatInput = _require2.formatInput;
    var _require3 = require_helpers();
    var checkType = _require3.checkType;
    var Workflow = function() {
      function Workflow2(_config) {
        var rawData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        _classCallCheck(this, Workflow2);
        this._config = _config;
        this.rawData = rawData;
        this.id = rawData.id;
        this.createdAt = rawData.created_at || rawData.createdAt;
        this.appId = rawData.app_id || rawData.appId;
      }
      _createClass(Workflow2, [{
        key: "create",
        value: function create(workflowId, config) {
          var url = "" + this._config.basePath + WORKFLOWS_PATH;
          var modelId = config.modelId;
          var modelVersionId = config.modelVersionId;
          var body = {
            workflows: [{
              id: workflowId,
              nodes: [{
                id: "concepts",
                model: {
                  id: modelId,
                  model_version: {
                    id: modelVersionId
                  }
                }
              }]
            }]
          };
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.post(url, body, {
                headers
              }).then(function(response) {
                var workflowId2 = response.data.workflows[0].id;
                resolve(workflowId2);
              }, reject);
            });
          });
        }
        /**
         * @deprecated
         */
      }, {
        key: "delete",
        value: function _delete(workflowId, config) {
          var url = "" + this._config.basePath + replaceVars(WORKFLOW_PATH, [workflowId]);
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.delete(url, {
                headers
              }).then(function(response) {
                var data = response.data;
                resolve(data);
              }, reject);
            });
          });
        }
        /**
         * Returns workflow output according to inputs
         * @param {string}                   workflowId    Workflow id
         * @param {object[]|object|string}   inputs    An array of objects/object/string pointing to an image resource. A string can either be a url or base64 image bytes. Object keys explained below:
         *    @param {object}                  inputs[].image     Object with keys explained below:
         *       @param {string}                 inputs[].image.(url|base64)  Can be a publicly accessibly url or base64 string representing image bytes (required)
         * @param {object} config An object with keys explained below.
         *   @param {float} config.minValue The minimum confidence threshold that a result must meet. From 0.0 to 1.0
         *   @param {number} config.maxConcepts The maximum number of concepts to return
         */
      }, {
        key: "predict",
        value: function predict(workflowId, inputs) {
          var config = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var url = "" + this._config.basePath + replaceVars(WORKFLOW_RESULTS_PATH, [workflowId]);
          if (checkType(/(Object|String)/, inputs)) {
            inputs = [inputs];
          }
          return wrapToken2(this._config, function(headers) {
            var params = {
              inputs: inputs.map(formatInput)
            };
            if (config && Object.getOwnPropertyNames(config).length > 0) {
              params["output_config"] = (0, _utils.formatObjectForSnakeCase)(config);
            }
            return new Promise(function(resolve, reject) {
              axios.post(url, params, {
                headers
              }).then(function(response) {
                var data = response.data;
                resolve(data);
              }, reject);
            });
          });
        }
      }]);
      return Workflow2;
    }();
    module.exports = Workflow;
  }
});

// node_modules/clarifai/dist/Workflows.js
var require_Workflows = __commonJS({
  "node_modules/clarifai/dist/Workflows.js"(exports, module) {
    "use strict";
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var axios = require_axios();
    var Workflow = require_Workflow();
    var _require = require_constants();
    var API = _require.API;
    var replaceVars = _require.replaceVars;
    var WORKFLOWS_PATH = API.WORKFLOWS_PATH;
    var WORKFLOW_PATH = API.WORKFLOW_PATH;
    var _require2 = require_utils();
    var wrapToken2 = _require2.wrapToken;
    var _require3 = require_helpers();
    var isSuccess2 = _require3.isSuccess;
    var Workflows = function() {
      function Workflows2(_config) {
        var _this = this;
        var rawData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        _classCallCheck(this, Workflows2);
        this._config = _config;
        this.rawData = rawData;
        rawData.forEach(function(workflowData, index) {
          _this[index] = new Workflow(_this._config, workflowData);
        });
        this.length = rawData.length;
      }
      _createClass(Workflows2, [{
        key: "list",
        value: function list() {
          var _this2 = this;
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { page: 1, perPage: 20 };
          var url = "" + this._config.basePath + WORKFLOWS_PATH;
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.get(url, {
                headers,
                params: {
                  page: options.page,
                  per_page: options.perPage
                }
              }).then(function(response) {
                if (isSuccess2(response)) {
                  resolve(new Workflows2(_this2._config, response.data.workflows));
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
      }, {
        key: "create",
        value: function create(workflowId, config) {
          var url = "" + this._config.basePath + WORKFLOWS_PATH;
          var modelId = config.modelId;
          var modelVersionId = config.modelVersionId;
          var body = {
            workflows: [{
              id: workflowId,
              nodes: [{
                id: "concepts",
                model: {
                  id: modelId,
                  model_version: {
                    id: modelVersionId
                  }
                }
              }]
            }]
          };
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.post(url, body, {
                headers
              }).then(function(response) {
                var workflowId2 = response.data.workflows[0].id;
                resolve(workflowId2);
              }, reject);
            });
          });
        }
      }, {
        key: "delete",
        value: function _delete(workflowId) {
          var url = "" + this._config.basePath + replaceVars(WORKFLOW_PATH, [workflowId]);
          return wrapToken2(this._config, function(headers) {
            return new Promise(function(resolve, reject) {
              axios.delete(url, {
                headers
              }).then(function(response) {
                var data = response.data;
                resolve(data);
              }, reject);
            });
          });
        }
      }]);
      return Workflows2;
    }();
    module.exports = Workflows;
  }
});

// node_modules/clarifai/dist/solutions/Moderation.js
var require_Moderation = __commonJS({
  "node_modules/clarifai/dist/solutions/Moderation.js"(exports, module) {
    "use strict";
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var axios = require_axios();
    var _require = require_utils();
    var wrapToken2 = _require.wrapToken;
    var _require2 = require_helpers();
    var isSuccess2 = _require2.isSuccess;
    var clone = _require2.clone;
    var BASE_URL = "https://api.clarifai-moderation.com";
    var Moderation = function() {
      function Moderation2(_config) {
        _classCallCheck(this, Moderation2);
        this._config = _config;
      }
      _createClass(Moderation2, [{
        key: "predict",
        value: function predict(modelID, imageURL) {
          return wrapToken2(this._config, function(headers) {
            var url = BASE_URL + "/v2/models/" + modelID + "/outputs";
            var params = {
              inputs: [{
                data: {
                  image: {
                    url: imageURL
                  }
                }
              }]
            };
            return new Promise(function(resolve, reject) {
              return axios.post(url, params, { headers }).then(function(response) {
                if (isSuccess2(response)) {
                  var data = clone(response.data);
                  resolve(data);
                } else {
                  reject(response);
                }
              }, reject);
            });
          });
        }
      }, {
        key: "getModerationStatus",
        value: function getModerationStatus(imageID) {
          return wrapToken2(this._config, function(headers) {
            var url = BASE_URL + "/v2/inputs/" + imageID + "/outputs";
            return new Promise(function(resolve, reject) {
              return axios.get(url, { headers }).then(function(response) {
                var data = clone(response.data);
                resolve(data);
              }, reject);
            });
          });
        }
      }]);
      return Moderation2;
    }();
    module.exports = Moderation;
  }
});

// node_modules/clarifai/dist/solutions/Solutions.js
var require_Solutions = __commonJS({
  "node_modules/clarifai/dist/solutions/Solutions.js"(exports, module) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Moderation = require_Moderation();
    var Solutions = function Solutions2(_config) {
      _classCallCheck(this, Solutions2);
      this.moderation = new Moderation(_config);
    };
    module.exports = Solutions;
  }
});

// node_modules/clarifai/dist/App.js
var require_App = __commonJS({
  "node_modules/clarifai/dist/App.js"(exports, module) {
    "use strict";
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var axios = require_axios();
    var _require = require_helpers();
    var checkType = _require.checkType;
    var Models = require_Models();
    var Inputs = require_Inputs();
    var Concepts = require_Concepts();
    var Workflow = require_Workflow();
    var Workflows = require_Workflows();
    var Solutions = require_Solutions();
    var _require2 = require_constants();
    var API = _require2.API;
    var ERRORS = _require2.ERRORS;
    var getBasePath = _require2.getBasePath;
    var TOKEN_PATH = API.TOKEN_PATH;
    if (typeof window !== "undefined" && !("Promise" in window)) {
      window.Promise = require_promise();
    }
    if (typeof global !== "undefined" && !("Promise" in global)) {
      global.Promise = require_promise();
    }
    var App = function() {
      function App2(arg1, arg2, arg3) {
        _classCallCheck(this, App2);
        var optionsObj = arg1;
        if ((typeof arg1 === "undefined" ? "undefined" : _typeof(arg1)) !== "object" || arg1 === null) {
          optionsObj = arg3 || {};
          optionsObj.clientId = arg1;
          optionsObj.clientSecret = arg2;
        }
        this._validate(optionsObj);
        this._init(optionsObj);
      }
      _createClass(App2, [{
        key: "getToken",
        value: function getToken() {
          return this._config.token();
        }
        /**
         * Sets the token to use for the API
         * @param {String}         _token    The token you are setting
         * @return {Boolean}                 true if token has valid fields, false if not
         *
         * @deprecated Please switch to using the API key.
         */
      }, {
        key: "setToken",
        value: function setToken(_token) {
          var token = _token;
          var now = (/* @__PURE__ */ new Date()).getTime();
          if (typeof _token === "string") {
            token = {
              accessToken: _token,
              expiresIn: 176400
            };
          } else {
            token = {
              accessToken: _token.access_token || _token.accessToken,
              expiresIn: _token.expires_in || _token.expiresIn
            };
          }
          if (token.accessToken && token.expiresIn || token.access_token && token.expires_in) {
            if (!token.expireTime) {
              token.expireTime = now + token.expiresIn * 1e3;
            }
            this._config._token = token;
            return true;
          }
          return false;
        }
      }, {
        key: "_validate",
        value: function _validate(_ref) {
          var clientId = _ref.clientId, clientSecret = _ref.clientSecret, token = _ref.token, apiKey = _ref.apiKey, sessionToken = _ref.sessionToken;
          if (clientId || clientSecret) {
            console.warn("Client ID/secret has been deprecated. Please switch to using the API key. See here how to do the switch: https://blog.clarifai.com/introducing-api-keys-a-safer-way-to-authenticate-your-applications");
          }
          if ((!clientId || !clientSecret) && !token && !apiKey && !sessionToken) {
            throw ERRORS.paramsRequired(["apiKey"]);
          }
        }
      }, {
        key: "_init",
        value: function _init(options) {
          var _this = this;
          var apiEndpoint = options.apiEndpoint || process && process.env && process.env.API_ENDPOINT || "https://api.clarifai.com";
          this._config = {
            apiEndpoint,
            clientId: options.clientId,
            clientSecret: options.clientSecret,
            apiKey: options.apiKey,
            sessionToken: options.sessionToken,
            basePath: getBasePath(apiEndpoint, options.userId, options.appId),
            token: function token() {
              return new Promise(function(resolve, reject) {
                var now = (/* @__PURE__ */ new Date()).getTime();
                if (checkType(/Object/, _this._config._token) && _this._config._token.expireTime > now) {
                  resolve(_this._config._token);
                } else {
                  _this._getToken(resolve, reject);
                }
              });
            }
          };
          if (options.token) {
            this.setToken(options.token);
          }
          this.models = new Models(this._config);
          this.inputs = new Inputs(this._config);
          this.concepts = new Concepts(this._config);
          this.workflow = new Workflow(this._config);
          this.workflows = new Workflows(this._config);
          this.solutions = new Solutions(this._config);
        }
        /**
         * @deprecated Please switch to using the API key.
         */
      }, {
        key: "_getToken",
        value: function _getToken(resolve, reject) {
          var _this2 = this;
          this._requestToken().then(function(response) {
            if (response.status === 200) {
              _this2.setToken(response.data);
              resolve(_this2._config._token);
            } else {
              reject(response);
            }
          }, reject);
        }
        /**
         * @deprecated Please switch to using the API key.
         */
      }, {
        key: "_requestToken",
        value: function _requestToken() {
          var url = "" + this._config.basePath + TOKEN_PATH;
          var clientId = this._config.clientId;
          var clientSecret = this._config.clientSecret;
          return axios({
            "url": url,
            "method": "POST",
            "auth": {
              "username": clientId,
              "password": clientSecret
            }
          });
        }
      }]);
      return App2;
    }();
    module.exports = App;
  }
});

// node_modules/clarifai/dist/index.js
var require_dist = __commonJS({
  "node_modules/clarifai/dist/index.js"(exports, module) {
    var App = require_App();
    var _require = require_package();
    var version = _require.version;
    module.exports = global.Clarifai = {
      version,
      App,
      GENERAL_MODEL: "aaa03c23b3724a16a56b629203edc62c",
      FOOD_MODEL: "bd367be194cf45149e75f01d59f77ba7",
      TRAVEL_MODEL: "eee28c313d69466f836ab83287a54ed9",
      NSFW_MODEL: "e9576d86d2004ed1a38ba0cf39ecb4b1",
      WEDDINGS_MODEL: "c386b7a870114f4a87477c0824499348",
      WEDDING_MODEL: "c386b7a870114f4a87477c0824499348",
      COLOR_MODEL: "eeed0b6733a644cea07cf4c60f87ebb7",
      CLUSTER_MODEL: "cccbe437d6e54e2bb911c6aa292fb072",
      FACE_DETECT_MODEL: "a403429f2ddf4b49b307e318f00e528b",
      FOCUS_MODEL: "c2cf7cecd8a6427da375b9f35fcd2381",
      LOGO_MODEL: "c443119bf2ed4da98487520d01a0b1e3",
      DEMOGRAPHICS_MODEL: "c0c0ac362b03416da06ab3fa36fb58e3",
      GENERAL_EMBED_MODEL: "bbb5f41425b8468d9b7a554ff10f8581",
      FACE_EMBED_MODEL: "d02b4508df58432fbb84e800597b8959",
      APPAREL_MODEL: "e0be3b9d6a454f0493ac3a30784001ff",
      MODERATION_MODEL: "d16f390eb32cad478c7ae150069bd2c6",
      TEXTURES_AND_PATTERNS: "fbefb47f9fdb410e8ce14f24f54b47ff",
      LANDSCAPE_QUALITY: "bec14810deb94c40a05f1f0eb3c91403",
      PORTRAIT_QUALITY: "de9bd05cfdbf4534af151beb2a5d0953",
      CELEBRITY_MODEL: "e466caa0619f444ab97497640cefc4dc"
    };
  }
});
export default require_dist();
//# sourceMappingURL=clarifai.js.map
